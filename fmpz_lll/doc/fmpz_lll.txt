/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 William Hart
    Copyright (C) 2010-2011 Andy Novocin
    Copyright (C) 2010-2011 Fredrik Johansson
    Copyright (C) 2014 Abhinav Baid

******************************************************************************/


*******************************************************************************

    Heuristic dot product

*******************************************************************************

double fmpz_lll_heuristic_dot(const double * vec1, const double * vec2,
               slong len2, const fmpz_mat_t B, slong k, slong j, slong exp_adj)

    Computes the dot product of two vectors of doubles \code{vec1} and
    \code{vec2}, which are respectively \code{double} approximations (up to
    scaling by a power of 2) to rows \code{k} and \code{j} in the exact integer
    matrix \code{B}. If massive cancellation is detected an exact computation
    is made.

    The exact computation is scaled by \code{2^{-exp_adj}}, where
    \code{exp_adj = r2 + r1} where $r2$ is the exponent for row \code{j} and
    $r1$ is the exponent for row \code{k} (i.e. row \code{j} is notionally
    thought of as being multiplied by $2^{r2}$, etc.).

    The final dot product computed by this function is then notionally the
    return value times \code{2^{exp_adj}}.

*******************************************************************************

    The various Babai's

*******************************************************************************

int fmpz_lll_check_babai(int kappa, fmpz_mat_t B, d_mat_t mu, d_mat_t r,
                      double *s, d_mat_t appB, int *expo, d_mat_t appSP, int a,
                      int zeros, int kappamax, int n, double delta, double eta)

    Performs floating point size reductions of the \code{kappa}-th row of
    \code{B} by all of the previous rows, uses d_mats \code{mu} and \code{r}
    for storing the GSO data. The \code{double} array \code{s} will contain the
    size of the \code{kappa}-th row if it were moved into position $i$. The
    d_mat \code{appB} is an approximation of \code{B} with each row receiving
    an exponent stored in \code{expo} which gets populated only when needed.
    The d_mat \code{appSP} is an approximation of the Gram matrix whose entries
    are scalar products of the rows of \code{B}. The index \code{a} is the
    smallest row index which will be reduced from the \code{kappa}-th row.
    Index \code{zeros} is the number of zero rows in the matrix.
    \code{kappamax} is the highest index which has been size-reduced so far,
    and \code{n} is the number of columns you want to consider. \code{delta}
    and \code{eta} are the LLL (L^2) parameters. The output is the value -1 if
    the process fails (usually due to insufficient precision) or 0 if
    everything was successful. These descriptions will be true for the future
    Babai procedures as well.

int fmpz_lll_check_babai_heuristic_d(int kappa, fmpz_mat_t B, d_mat_t mu,
               d_mat_t r, double *s, d_mat_t appB, int *expo, d_mat_t appSP,
               int a, int zeros, int kappamax, int n, double delta, double eta)

    Same as \code{fmpz_lll_check_babai()} but using the heuristic inner product
    rather than a purely floating point inner product. The heuristic will
    compute at full precision when there is cancellation.

*******************************************************************************

    Shift

*******************************************************************************

int fmpz_lll_shift(const fmpz_mat_t B)

    Computes the largest number of non-zero entries after the diagonal in
    \code{B}.
