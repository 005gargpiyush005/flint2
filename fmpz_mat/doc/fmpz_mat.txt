/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 William Hart
    Copyright (C) 2010 Andy Novocin
    Copyright (C) 2010 Fredrik Johansson

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void fmpz_mat_init(fmpz_mat_t mat, long rows, long cols)

    Initialises a matrix with the given number of rows and columns for use. 

void fmpz_mat_clear(fmpz_mat_t mat)

    Clears the given matrix.

void fmpz_mat_swap(fmpz_mat_t mat1, fmpz_mat_t mat2)

    Swaps two matrices. The dimensions of mat1 and mat2 are allowed to be
    different.

void fmpz_mat_print(fmpz_mat_t mat) 

    Prints the given matrix to stdout. The format is the number of rows, a
    space, the number of columns, two spaces, then a space separated list
    of coefficients.

void fmpz_mat_print_pretty(fmpz_mat_t mat) 

    Prints the given matrix to stdout. The format is an opening square bracket
    then on each line a row of the matrix, followed by a closing square 
    bracket. Each row is written as an opening square bracket followed by a
    space separated list of coefficients followed by a closing square bracket.


*******************************************************************************

    Random matrix generation

*******************************************************************************

void fmpz_mat_randinit(fmpz_randstate_t state)

    Initialises the fmpz_mat randstate.

void fmpz_mat_randclear(fmpz_randstate_t state)

    Clears the fmpz_mat randstate.

void fmpz_mat_randbits(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits)

    Sets the entries of mat to random signed integers whose absolute values
    have the given number of binary bits.

void fmpz_mat_randtest(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits)

    Sets the entries of mat to random signed integers whose absolute values 
    have a random number of bits up to the given number of bits inclusive.

void fmpz_mat_randintrel(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits)

    Sets mat to be a random "integer relations" matrix, with signed entries up 
    to the given number of bits. The number of columns of mat must be equal 
    to one more than the number of rows. The format of the matrix is a set of
    random integers in the left hand column and an identity matrix in the 
    remaining square submatrix.

void fmpz_mat_randsimdioph(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits, mp_bitcnt_t bits2)

    Sets mat to a random "simultaneous diophantine" matrix. The matrix must
    be square. The top left entry is set to 2^bits2. The remainder of that
    row is then set to signed random integers of the given number of binary 
    bits. The remainder of the first column is zero. Running down the rest of
    the diagonal are the values 2^bits with all remaining entries zero.
  
void fmpz_mat_randntrulike(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits, ulong q)
   
    Sets a square matrix mat of even dimension to a random "NTRU like" matrix.
    The matrix is broken into four square submatrices. The top left submatrix
    is set to the identity. The bottom left submatrix is set to the zero 
    matrix. The bottom right submatrix is set to q times the identity matrix.
    Finally the top right submatrix has the following format. A random vector
    h of length r/2 is created, with random signed entries of the given number
    of bits. Then entry (i, j) of the submatrix is set to h[i + j (mod r/2)]. 

void fmpz_mat_randntrulike2(fmpz_mat_t mat, fmpz_randstate_t state, mp_bitcnt_t bits, ulong q)
   
    Sets a square matrix mat of even dimension to a random "NTRU like" matrix.
    The matrix is broken into four square submatrices. The top left submatrix
    is set to q times the identity matrix. The top right submatrix is set to 
    the zero matrix. The bottom right submatrix is set to the identity matrix.
    Finally the bottom left submatrix has the following format. A random vector
    h of length r/2 is created, with random signed entries of the given number
    of bits. Then entry (i, j) of the submatrix is set to h[i + j (mod r/2)]. 

void fmpz_mat_randajtai(fmpz_mat_t mat, fmpz_randstate_t state, double alpha)

    Sets a square matrix mat to a random "ajtai" matrix. The diagonal entries 
    (i, i) are set to a random entry in the range [1, 2^{b-1}] inclusive where
    b = floor((2*r - i)^alpha) for some double parameter alpha. The entries 
    below the diagonal in column i are set to a random entry in the range 
    (-2^b + 1, 2^b - 1) whilst the entries to the right of the diagonal in 
    row i are set to zero. 

int fmpz_mat_randpermdiag(fmpz_mat_t mat, fmpz_randstate_t state, const fmpz * diag, long n)

    Sets mat to a random permutation of the rows and columns of a
    given diagonal matrix. The diagonal matrix is specified in the form of
    an array of the n initial entries on the main diagonal.

    The return value is 0 or 1 depending on whether the permutation is
    even or odd.

void fmpz_mat_randrank(fmpz_mat_t mat, fmpz_randstate_t state, long rank, mp_bitcnt_t bits)

    Sets mat to a random sparse matrix with the given rank (having
    exactly as many nonzero elements as the rank), with the nonzero
    elements being random integers of the given bit size.

    The matrix can be transformed into a dense matrix with unchanged
    rank by subsequently calling fmpz_mat_randops.

void fmpz_mat_randdet(fmpz_mat_t mat, fmpz_randstate_t state, const fmpz_t det)

    Sets mat to a random sparse matrix with minimal number of nonzero
    entries such that its determinant has the given value. (Note that
    the matrix will be zero if det = 0; use fmpz_mat_randrank to generate
    a nonzero singular matrix.)

    The matrix can be transformed into a dense matrix with unchanged
    determinant by subsequently calling fmpz_mat_randops.

void fmpz_mat_randops(fmpz_mat_t mat, fmpz_randstate_t state, long count)

    Randomises mat by performing elementary row or column operations.
    More precisely, at most count random additions or subtractions of
    distinct rows and columns will be performed. This leaves the rank
    (and for square matrices, determinant) unchanged.



*******************************************************************************

    Linear algebra operations

*******************************************************************************

void fmpz_mat_transpose(fmpz_mat_t B, const fmpz_mat_t A)

    Sets B to A^T, the transpose of A. Dimensions must be compatible.
    A and B are allowed to be the same object if A is a square matrix.


void fmpz_mat_mul(fmpz_mat_t C, const fmpz_mat_t A, const fmpz_mat_t B)

    Sets C to the matrix product A * B. The matrices must have
    compatible dimensions for matrix multiplication.


void fmpz_mat_det(fmpz_t det, fmpz_mat_t A)

    Sets det to the determinant of the square matrix A.

    The determinant is computed using cofactor expansion for matrices up
    to size 4x4, and in general using row reduction.


long fmpz_mat_rank(fmpz_mat_t A)

    Returns the rank, or number of linearly independent columns
    (equivalently, rows), of A. The rank is computed by row reducing
    a copy of A.


void fmpz_mat_solve(fmpz * xnum, fmpz_t xden, const fmpz_mat_t A, const fmpz * b)

    Solves Ax = b, where A is assumed to be square and of full rank, by
    computing an integer vector xnum and integer xden such that
    x = xnum / xden. {xnum, xden} will not generally be reduced to lowest
    terms. If A is singular, xden will be set to zero.

    Direct solution formulas (Cramer's rule) are used for systems up to
    size 3x3. For larger systems, row reduction is used.


long _fmpz_mat_rowreduce(fmpz ** a, long m, long n, int variant)

    Row reduces the matrix in-place using fraction-free Gaussian elimination.
    The number of rows m and columns n may be arbitrary. The 'variant' can
    be one of the following:

    ROWREDUCE_ECHELON_FORM

        Standard row reduction, i.e. only eliminates elements below
        each pivot element.

    ROWREDUCE_REDUCED_ECHELON_FORM

        Full (Gauss-Jordan) reduction, eliminating elements both below
        and above each pivot element.

    ROWREDUCE_DETONLY

        Standard row reduction, but immediately aborts and returns 0
        if the matrix is detected to be singular. In this event,
        the state of the matrix will be undefined.

    Pivoting (to avoid division by zero entries) is performed by permuting
    the vector of row pointers in-place. The matrix entries themselves
    retain their original order in memory.

    The return value r is the rank of the matrix, multiplied by a sign
    indicating the parity of row interchanges. If r = 0, the matrix has rank
    zero. Otherwise, the leading nonzero entries of a[0], a[1], ... a[abs(r)-1]
    will point to the successive pivot elements. If |r| = m = n, the
    determinant of the matrix is given by sign(r) * a[|r|-1][|r|-1].
