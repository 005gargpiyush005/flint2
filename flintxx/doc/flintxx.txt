/*=============================================================================
vim: spell spelllang=en textwidth=79

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2013 Tom Bachmann

******************************************************************************/

*******************************************************************************

    flint\_exception

    This is the main exception type used by the flintxx library. It derives
    from \code{std::domain_error}. As such its main method is \code{what()},
    yielding an English language description of the problem encountered.

*******************************************************************************

*******************************************************************************

    frandxx

    The type \code{frandxx} wraps \code{flint_rand_t} and takes care of
    initialising and clearing random states. It is defined in
    \code{flintxx/frandxx.h}. Note that this type is not copyable.

*******************************************************************************

frandxx::frandxx()

    Initialize random state.

flint_rand_t& frandxx::_data()
const flint_rand_t& frandxx::_data() const

    Obtain a reference to the underlying C random state.


*******************************************************************************

    ltuple

    Lazy tuples are implemented in \code{flintxx/ltuple.h}. They are used
    throughout flintxx to emulate functions with several return values.

*******************************************************************************

Ltuple<T1&, ..., Tn&> ltupleref(T1& t1, ..., Tn& tn)

    Construct an ltuple of references, binding to the arguments \code{t1},
    \dots, \code{tn}. Instances of \code{flint::detail::IGNORED_TYPE} can be
    used as placeholders.

Ltuple<T1, ..., Tn> ltuple(const T1& t1, ..., const Tn& tn)

    Construct an ltuple containing copies of \code{t1}, \dots, \code{tn}.

Tk_expr Ltuple<T1, ..., Tn>_expr::get<k>() const

    If \code{Tk} is an expression template type, then the \code{get<k>()}
    method returns a lazy expression evaluating to the kth element of the
    (potentially lazy) ltuple.

    If \code{Tk} is not an expression template type, this method evaluates the
    ltuple, and returns the kth entry.

    On ltuple immediates, reference versions are also available, which can
    be used to manipulate the entries.


*******************************************************************************

    fmpzxx

*******************************************************************************

fmpzxx::fmpzxx()

    Initialize to zero.

fmpzxx::fmpzxx(const char*)
fmpzxx::fmpzxx(T:is_integer)

    Initialize from a primitive data type. See \code{fmpz_set_str},
    \code{fmpz_set_si} and \code{fmpz_set_ui}.

static fmpzxx fmpzxx::randbits(frandxx& state)

static fmpzxx fmpzxx::randtest(frandxx& state)

static fmpzxx fmpzxx::randtest_unsigned(frandxx& state)

static fmpzxx fmpzxx::randtest_not_zero(frandxx& state)

static fmpzxx fmpzxx::randm(frandxx& state, Fmpz_expr m)

static fmpzxx fmpzxx::randtest_mod(frandxx& state, Fmpz_expr m)

static fmpzxx fmpzxx::randtest_mod_signed(frandxx& state, Fmpz_expr m)

static slong fmpzxx::remove(Fmpz_expr rop, Fmpz_expr op, Fmpz_expr f)

static fmpzxx_ref fmpzxx_ref::make(fmpz* f)
static fmpzxx_srcref fmpzxx_srcref::make(const fmpz* f)

    Obtain a flintxx reference object pointing to \code{f}. Here \code{f} must
    not be zero.

fmpz_t& fmpzxx::_fmpz()
const fmpz_t& fmpzxx::_fmpz() const
fmpz* fmpzxx_ref::_fmpz()
const fmpz* fmpzxx_ref::_fmpz() const
const fmpz* fmpzxx_srcref::_fmpz() const

    Obtain a reference to the underlying C data type.

void Fmpz_target::set_ui_smod(mp_limb_t x, mv_limb_t m)

void Fmpz_target::set_ui_ui(mp_limb_t x, mv_limb_t m)

void Fmpz_target::neg_ui_ui(mp_limb_t x, mv_limb_t m)

void Fmpz_target::clrbit(ulong i)

void Fmpz_target::combit(ulong i)

double Fmpz_expr::get_d_2exp(long& exp) const

bool Fmpz_expr::is_zero() const

    Return if this expression evaluates to zero.

bool Fmpz_expr::is_one() const

    Return if this expression evaluates to one.

bool Fmpz_expr::is_pm1() const

    Return if this expression evaluates to $\pm 1$.

bool Fmpz_expr::is_even() const

    Return if this expression evaluates to an even integer.

bool Fmpz_expr::is_odd() const

    Return if the expression evaluates to an odd integer.

bool Fmpz_expr::is_square() const

    Return if this expression evaluates to a square integer.

int Fmpz_expr::popcnt() const

bool Fmpz_expr::is_probabprime() const

bool Fmpz_expr::is_prime_pseudosquare() const

bool Fmpz_expr::divisible(Fmpz_expr) const
bool Fmpz_expr::divisible(T:fits_into_slong) const

long Fmpz_expr::clog(Fmpz_expr) const
long Fmpz_expr::clog(T:is_unsigned_integer) const

long Fmpz_expr::flog(Fmpz_expr) const
long Fmpz_expr::flog(T:is_unsigned_integer) const

double Fmpz_expr::dlog() const

int Fmpz_expr::jacobi(Fmpz_expr) const

std::string Fmpz_expr::to_string(int base = 10) const

    Convert self into a \code{string}. See \code{fmpz_get_str}.

slong Fmpz_expr::to<slong>() const

    Convert self to \code{slong}. See \code{fmpz_get_si}.

double Fmpz_expr::to<double>() const

    Convert self to \code{double}. See \code{fmpz_get_d}.

Fmpz_expr::unary operation() const

    The following unary functions are made available as member functions:
    \code{sqrt}, \code{abs}.

Fmpz_expr::binary operation(??) const

    The following binary functions are made available as member functions:
    \code{cdiv_q}, \code{divexact}, \code{fdiv_qr}, \code{fdiv_r},
    \code{fdiv_r_2exp}, \code{gcd}, \code{gcdinv}, \code{invmod}, \code{lcm},
    \code{negmod}, \code{pow}, \code{rfac}, \code{root}, \code{sqrtmod},
    \code{tdiv_q}, \code{tdiv_q_2exp}, \code{tdiv_qr}, \code{xgcd}.

Fmpz_expr::ternary operation(??, ??) const

    The following ternary functions are made available as member functions:
    \code{divexact2}, \code{mul2}, \code{mul_tdiv_q_2exp}, \code{powm}.

Fmpz_target Fmpz_target::operator=(const char*)
Fmpz_target Fmpz_target::operator=(T:is_integer)

    See \code{fmpz_set_str}, \code{fmpz_set_ui} and \code{fmpz_set_si}.

bool operator??(?? e1, ?? e2)

    Relational operators \code{<=}, \code{>}
    etc are overloaded, where e1 and e2 can be any
    combination of \code{Fmpz_expr},
    \code{T:is_signed_integer} and \code{T:is_unsigned_integer}.
    See \code{fmpz_cmp}, \code{fmpz_cmp_si} and \code{fmpz_cmp_ui}.

Fmpz_expr operator?(?? e1, ?? e2)

    Arithmetic operators \code{+}, \code{-}, \code{*}, \code{/}, \code{%},
    \code{<<} and \code{>>} are overloaded. See the \code{fmpz} documentation
    for which argument types are allowed. Symmetric operators with asymmetric
    type arguments can be used in either order, even if this is not exposed in
    the C interface.

    The shift operators wrap \code{fmpz_fdiv_q_2exp} and \code{fmpz_mul_2exp}.
    The division operators use \code{fmpz_fdiv}.

    Binary logic operators \code{& | ^} (and, or, xor) are also overloaded
    (implemented when both arguments are \code{Fmpz_expr}).

Fmpz_target operator?=(?? e)

    Assignment-arithmetic operators are overloaded whenever their long form
    would be.

Fmpz_expr operator-(Fmpz_expr)

    Negate the argument. See \code{fmpz_neg}.

bool divisible(Fmpz_expr n, Fmpz_expr d)
bool divisible(Fmpz_expr n, T:fits_into_slong d)

    Return if $d$ divides $n$. See \code{fmpz_divisible}.

long clog(Fmpz_expr x, Fmpz_expr b)
long clog(Fmpz_expr x, ulong b)

long flog(Fmpz_expr x, Fmpz_expr b)
long flog(Fmpz_expr x, ulong b)

double dlog(Fmpz_expr x)

int jacobi(Fmpz_expr a, Fmpz_expr p)

fmpzxx mul2_uiui(Fmpz_expr g, ulong x, ulong y)

fmpzxx divexact2_uiui(Fmpz_expr g, ulong x, ulong y)

fmpzxx powm(Fmpz_expr g, ulong e, Fmpz_expr m)
fmpzxx powm(Fmpz_expr g, Fmpz_expr e, Fmpz_expr m)

fmpzxx mul_tdiv_q_2exp(Fmpz_expr g, Fmpz_expr x, ulong exp)
fmpzxx mul_tdiv_q_2exp(Fmpz_expr g, long x, ulong exp)

void fdiv_qr(Fmpz_target f, Fmpz_target s, Fmpz_expr g, Fmpz_expr h)

void tdiv_qr(Fmpz_target f, Fmpz_target s, Fmpz_expr g, Fmpz_expr h)

bool sqrtmod(Fmpz_target b, Fmpz_expr a, Fmpz_expr b)

void sqrtrem(Fmpz_target f, Fmpz_target s, Fmpz_expr g)

void gcdinv(Fmpz_target d, Fmpz_target a, Fmpz_expr f, Fmpz_expr g)

void xgcd(Fmpz_target d, Fmpz_target a, Fmpz_target b, Fmpz_expr f,
        Fmpz_expr g)

Fmpz_expr rfac(Fmpz_expr, T:is_unsigned_integer)

Fmpz_expr fac(T:is_unsigned_integer)

Fmpz_expr fib(T:is_unsigned_integer)

Fmpz_expr bin(T:is_unsigned_integer, U:is_unsigned_integer)

Fmpz_expr gcd(Fmpz_expr, Fmpz_expr)

Fmpz_expr lcm(Fmpz_expr, Fmpz_expr)

Fmpz_expr invmod(Fmpz_expr, Fmpz_expr)

Fmpz_expr negmod(Fmpz_expr, Fmpz_expr)

Fmpz_expr cdiv_q(Fmpz_expr, Fmpz_expr)
Fmpz_expr cdiv_q(Fmpz_expr, T:is_integer)

Fmpz_expr tdiv_q(Fmpz_expr, Fmpz_expr)
Fmpz_expr tdiv_q(Fmpz_expr, T:is_integer)

Fmpz_expr divexact(Fmpz_expr, Fmpz_expr)
Fmpz_expr divexact(Fmpz_expr, T:is_integer)

Fmpz_expr fdiv_r(Fmpz_expr, Fmpz_expr)

Fmpz_expr tdiv_q_2exp(Fmpz_expr, T:is_unsigned_integer)

Fmpz_expr fdiv_r_2exp(Fmpz_expr, T:is_unsigned_integer)

Fmpz_expr pow(Fmpz_expr, T:is_unsigned_integer)

Fmpz_expr root(Fmpz_expr, T:fits_into_slong)

Fmpz_expr sqrt(Fmpz_expr)

Fmpz_expr abs(Fmpz_expr)


*******************************************************************************

    fmpqxx

*******************************************************************************

fmpqxx::fmqxx()

    Initialize to zero.

fmpqxx::fmpqxx(Fmpz_src num, Fmpz_src den)
fmpqxx::fmpqxx(T:fits_into_slong num, U:is_unsigned_integer den)

    Initialize from numerator \code{num} and denominator \code{den}.

static fmpqxx fmpqxx::randbits(frandxx& state)

static fmpqxx fmpqxx::randtest(frandxx& state)

static fmpqxx fmpqxx::randtest_not_zero(frandxx& state)

template<class Vec> static fmpqxx fmpqxx::from_cfrac(const Vec& v, slong n)

    Initialize from a partial fraction expansion. \code{v} must be an instance
    of a class which provides a method \code{_array()} that returns (a
    pointer to) an array of \code{fmpz}. One such class is \code{fmpz_vecxx}.
    The array must have size (at least) \code{n}.

static fmpqxx fmpqxx::reconstruct(Fmpz_expr a, Fmpz_expr m, Fmpz_expr N,
        Fmpz_expr D)
static Fmpq_expr fmpqxx::reconstruct(Fmpz_expr a, Fmpz_expr m)

    Rational reconstruction. May raise a \code{flint_exception} if
    reconstruction is not possible. See \code{fmpq_reconstruct_fmpz} and
    \code{fmpq_reconstruct_fmpz2}.

static fmpqxx_ref fmpzxx_ref::make(fmpq* f)
static fmpqxx_srcref fmpzxx_srcref::make(const fmpq* f)

    Obtain a flintxx reference object pointing to \code{*f}. Here \code{f} must
    not be zero.

fmpq* Fmpq_target::_fmpq()
const fmpq* Fmpq_src::_fmpq() const

    Obtain a reference to the underlying C data type.

Fmpq_ref Fmpq_target::num()
Fmpq_srcref Fmpq_src::num() const
Fmpq_ref Fmpq_target::den()
Fmpq_srcref Fmpq_src::den() const

    Obtain references to numerator/denominator.

void Fmpq_target::canonicalise()
bool Fmpq_src::is_canonical()

template<class Vec> void Fmpq_target::set_cfrac(const Vec& v, slong n)

    Set value to a partial fraction expansion. The same conventions apply to
    \code{v} as in the constructor.

std::string Fmpq_expr::to_string(int base = 10) const
bool Fmpq_expr::is_zero() const
bool Fmpq_expr::is_one() const
slong Fmpq_expr::cfrac_bound() const
int Fmpq_expr::sgn() const
mp_bitcnt_t Fmpq_expr::height_bits() const
Fmpq_expr Fmpq_expr::abs() const
Fmpq_expr Fmpq_expr::inv() const
Fmpz_expr Fmpq_expr::height() const
Fmpq_expr Fmpq_expr::pow(T:fits_into_slong) const

Fmpq_expr Fmpq_expr::next_minimal() const
Fmpq_expr Fmpq_expr::next_signed_minimal() const
Fmpq_expr Fmpq_expr::next_calkin_wilf() const
Fmpq_expr Fmpq_expr::next_signed_calkin_wilf() const

    Rational enumeration methods.

Fmpq_target operator=(T:fits_into_slong)

bool operator??(Fmpq_expr e1, Fmpq_expr e2)

    Relational operators are overloaded. See \code{fmpq_cmp}.

Fmpq_expr operator??(Fmpq_expr, Fmpq_expr)
Fmpq_expr operator*(Fmpq_expr, Fmpz_expr)
Fmpq_expr operator*(Fmpz_expr, Fmpq_expr)
Fmpq_expr operator/(Fmpq_expr, Fmpz_expr)
Fmpq_expr operator%(Fmpq_expr, Fmpz_expr)

    Arithmetic operators are overloaded for Fmpq arguments, and a few other
    combinations.
    The modular reduction operator may raise a \code{flint_exception} if
    modular inversion is not possible.

Fmpq_expr operator<<(Fmpq_expr, T:is_integer)
Fmpq_expr operator>>(Fmpq_expr, T:is_integer)

    Shift operators are overloaded. See \code{fmpq_div_2exp} and
    \code{fmpq_mul_2exp}.

Fmpq_expr operator-(Fmpq_expr)

    Negate the argument. See \code{fmpq_neg}.

mp_bitcnt_t height_bits(Fmpq_expr)

template<class Vec> int get_cfrac(Vec& v, Fmpq_target rem, Fmpq_expr x)

    Compute terms of the partial fraction expansion of x. The remainder is
    stored in \code{rem}. \code{v} must be an instance of a class providing
    \code{_array()} and \code{size()} methods, e.g. \code{fmpz_vecxx}.
    See \code{fmpq_get_cfrac}.

Fmpq_expr abs(Fmpq_expr)
Fmpq_expr height(Fmpq_expr)
Fmpq_expr inv(Fmpq_expr)
Fmpq_expr pow(Fmpq_expr, T:fits_into_slong)


*******************************************************************************

    fmpz\_polyxx

*******************************************************************************

fmpz_polyxx::fmpz_polyxx()

fmpz_polyxx::fmpz_polyxx(slong alloc)

    See \code{fmpz_poly_init2}.

static fmpz_polyxx fmpz_polyxx::randtest(
        frandxx& state, slong len, mp_bitcnt_t bits)
static fmpz_polyxx fmpz_polyxx::randtest_unsigned(
        frandxx& state, slong len, mp_bitcnt_t bits)
static fmpz_polyxx fmpz_polyxx::randtest_not_zero(
        frandxx& state, slong len, mp_bitcnt_t bits)

    See \code{fmpz_poly_randtest} etc.

static Fmpz_poly_expr fmpz_polyxx::interpolate(
        Fmpz_vec_expr xs, Fmpz_vec_expr ys)

    See \code{fmpz_poly_interpolate_fmpz_vec}.

static Fmpz_poly_expr fmpz_polyxx::product_roots(Fmpz_vec_expr xs)

    See \code{fmpz_poly_product_roots_fmpz_vec}.

void Fmpz_poly_target realloc(slong alloc)
void Fmpz_poly_target::fit_length(slong len)
void Fmpz_poly_target::_normalise()
void Fmpz_poly_target::_set_length(slong len)
void Fmpz_poly_target::zero_coeffs(slong i, slong j)

fmpzxx_ref Fmpz_poly_target::get_coeff(slong n)
fmpzxx_srcref Fmpz_poly_src::get_coeff(slong n) const

    Obtain a reference to coefficient $n$. The result is undefined if $n$ is
    greater than the degree of the polynomial (or negative).

fmpzxx_ref Fmpz_poly_target::lead()
fmpzxx_srcref Fmpz_poly_src::lead() const

    Obtain a reference to the leading coefficient. The result is undefined if
    the length of the polynomial is zero.

void Fmpz_poly_target::set_coeff(slong n, Fmpz_expr)
void Fmpz_poly_target::set_coeff(slong n, T:is_integer)

slong Fmpz_poly_expr::length() const
slong Fmpz_poly_expr::degree() const
bool Fmpz_poly_expr::is_one() const
bool Fmpz_poly_expr::is_zero() const
bool Fmpz_poly_expr::is_unit() const
ulong Fmpz_poly_expr::max_limbs() const
slong Fmpz_poly_expr::max_bits() const

std::string Fmpz_poly_expr::pretty(const char* x) const

    See \code{fmpz_poly_get_str_pretty}.

std::string Fmpz_poly_expr::to_string() const

void Fmpz_poly_expr::signature(slong& r1, slong& r2) const

    See \code{fmpz_poly_signature}.

Fmpz_poly_expr::unary operation() const

    The following unary functions are made available as member functions:
    \code{derivative}, \code{primitive_part}, \code{sqr}, \code{sqr_classical},
    \code{sqr_karatsuba}, \code{sqr_KS}, \code{sqrt}, \code{sqrt_classical},
    \code{content}, \code{height}.

Fmpz_expr Fmpz_poly_expr::bound_roots() const

    See \code{poly_bound_roots}.

Fmpz_expr Fmpz_poly_expr::norm() const

    See \code{poly_2norm}.

Fmpz_poly_expr::binary operation(??) const

    The following binary functions are made available as member functions:
    \code{compose_divconquer}, \code{compose_horner}, \code{div_basecase},
    \code{div_divconquer}, \code{divexact}, \code{divrem},
    \code{divrem_basecase}, \code{divrem_divconquer}, \code{div_root},
    \code{evaluate_divconquer}, \code{evaluate_horner}, \code{fdiv_2exp},
    \code{gcd}, \code{gcd_heuristic}, \code{gcd_modular},
    \code{gcd_subresultant}, \code{inv_series}, \code{inv_series_newton},
    \code{lcm}, \code{mul_2exp}, \code{mul_classical}, \code{mul_karatsuba},
    \code{mul_KS}, \code{mulmid_classical}, \code{mul_SS},
    \code{poly_shift_left}, \code{poly_shift_right}, \code{pow},
    \code{pow_addchains}, \code{pow_binexp}, \code{pow_binomial},
    \code{pow_multinomial}, \code{pseudo_div}, \code{pseudo_divrem},
    \code{pseudo_divrem_basecase}, \code{pseudo_divrem_cohen},
    \code{pseudo_divrem_divconquer}, \code{pseudo_rem},
    \code{pseudo_rem_cohen}, \code{resultant}, \code{reverse},
    \code{revert_series}, \code{revert_series_lagrange},
    \code{revert_series_lagrange_fast}, \code{revert_series_newton},
    \code{smod}, \code{sqrlow}, \code{sqrlow_classical},
    \code{sqrlow_karatsuba_n}, \code{sqrlow_KS}, \code{taylor_shift},
    \code{taylor_shift_horner}, \code{taylor_shift_divconquer}, \code{tdiv},
    \code{tdiv_2exp}, \code{xgcd}, \code{xgcd_modular}.

Fmpz_expr Fmpz_poly_expr::bit_pack(T:fits_into_mp_bitcnt_t) const

    See \code{poly_bit_pack}.

Fmpz_expr Fmpz_poly_expr::bit_unpack(T:fits_into_mp_bitcnt_t) const

    See \code{poly_bit_unpack}.

Fmpz_expr Fmpz_poly_expr::bit_unpack_unsigned(T:fits_into_mp_bitcnt_t) const

    See \code{poly_bit_unpack_unsigned}.

Ltuple<bool, fmpzxx_poly>_expr Fmpz_poly_expr::divides(Fmpz_poly_expr) const

    See \code{poly_divides}.

Fmpz_poly_expr::ternary operation(??, ??) const

    The following ternary functions are made available as member functions:
    \code{compose_series}, \code{compose_series_brent_kung},
    \code{compose_horner}, \code{div_series}, \code{mulhigh_classical},
    \code{mulhigh_karatsuba_n}, \code{mulhigh_n}, \code{mullow},
    \code{mullow_classical}, \code{mullow_karatsuba_n}, \code{mullow_KS},
    \code{mullow_SS}, \code{pow_trunc}.

Fmpz_poly_expr Fmpz_poly_expr::operator()(Fmpz_poly_expr) const
Fmpz_poly_expr Fmpz_poly_expr::operator()(Fmpz_expr) const

    Overloaded \code{operator()} for evaluation or composition.

Fmpz_poly_target Fmpz_poly_target::operator=(T:is_integer)
Fmpz_poly_target Fmpz_poly_target::operator=(Fmpz_expr)
Fmpz_poly_target Fmpz_poly_target::operator=(const char*)

Fmpz_poly_expr operator?(??, ??)

    Arithmetic operators \code{+ - * /} are overloaded if both arguments are
    polynomials, or one is a polynomial and one is an \code{Fmpz_expr} or
    integer.

Fmpz_poly_expr operator%(Fmpz_poly_expr, Fmpz_expr)
Fmpz_poly_expr operator%(Fmpz_poly_expr, Fmpz_poly_expr)

    See \code{fmpz_poly_scalar_mod_fmpz} and \code{fmpz_poly_rem}.

Fmpz_poly_expr smod(Fmpz_poly_expr, Fmpz_expr)

    See \code{fmpz_poly_scalar_smod_fmpz}.

Fmpz_poly_expr operator-(Fmpz_poly_expr)

Fmpz_poly_expr reverse(Fmpz_poly_expr, T:fits_into_slong)

Fmpz_poly_expr mul_2exp(Fmpz_poly_expr, T:is_unsigned_integer)
Fmpz_poly_expr fdiv_2exp(Fmpz_poly_expr, T:is_unsigned_integer)

Fmpz_poly_expr tdiv(Fmpz_poly_expr, Fmpz_expr)
Fmpz_poly_expr tdiv(Fmpz_poly_expr, T:is_integer)
Fmpz_poly_expr divexact(Fmpz_poly_expr, Fmpz_expr)
Fmpz_poly_expr divexact(Fmpz_poly_expr, T:is_integer)

Fmpz_expr poly_bit_pack(Fmpz_poly_expr, T:fits_into_mp_bitcnt_t)
Fmpz_poly_expr poly_bit_unpack(Fmpz_expr, T:fits_into_mp_bitcnt_t)
Fmpz_poly_expr poly_bit_unpack_unsigned(
        Fmpz_expr, traits::fits_into_mp_bitcnt_t)

Fmpz_poly_expr mul_classical(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr mulmid_classical(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr mul_karatsuba(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr mul_SS(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr mul_KS(Fmpz_poly_expr, Fmpz_poly_expr)

fmpz_polyxx mullow(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mullow_classical(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mullow_karatsuba_n(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mullow_KS(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mullow_SS(Fmpz_poly_expr, Fmpz_poly_expr, slong)

fmpz_polyxx mulhigh_n(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mulhigh_classical(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx mulhigh_karatsuba_n(Fmpz_poly_expr, Fmpz_poly_expr, slong)

Fmpz_poly_expr sqr(Fmpz_poly_expr)
Fmpz_poly_expr sqr_KS(Fmpz_poly_expr)
Fmpz_poly_expr sqr_karatsuba(Fmpz_poly_expr)
Fmpz_poly_expr sqr_classical(Fmpz_poly_expr)

Fmpz_poly_expr sqrlow(Fmpz_poly_expr, T:fits_into_slong n)
Fmpz_poly_expr sqrlow_classical(Fmpz_poly_expr, T:fits_into_slong n)
Fmpz_poly_expr sqrlow_KS(Fmpz_poly_expr, T:fits_into_slong n)
Fmpz_poly_expr sqrlow_karatsuba_n(Fmpz_poly_expr, T:fits_into_slong n)

Fmpz_poly_expr pow(Fmpz_poly_expr, T:is_unsigned_integer)
Fmpz_poly_expr pow_multinomial(Fmpz_poly_expr, T:is_unsigned_integer)
Fmpz_poly_expr pow_binomial(Fmpz_poly_expr, T:is_unsigned_integer)
Fmpz_poly_expr pow_binexp(Fmpz_poly_expr, T:is_unsigned_integer)
Fmpz_poly_expr pow_addchains(Fmpz_poly_expr, T:is_unsigned_integer)

fmpz_polyxx pow_trunc(Fmpz_poly_expr, ulong e, slong n)

Fmpz_poly_expr poly_shift_left(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr poly_shift_right(Fmpz_poly_expr, T:fits_into_slong)

Fmpz_expr height(Fmpz_poly_expr)
Fmpz_expr poly_2norm(Fmpz_poly_expr)

Fmpz_poly_expr gcd(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr gcd_subresultant(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr gcd_heuristic(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr gcd_modular(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr lcm(Fmpz_poly_expr, Fmpz_poly_expr)

fmpzxx xgcd(Fmpz_poly_target r, Fmpz_poly_target s, Fmpz_poly_expr f,
        Fmpz_poly_expr g)
fmpzxx xgcd_modular(Fmpz_poly_target r, Fmpz_poly_target s, Fmpz_poly_expr f,
        Fmpz_poly_expr g)

Fmpz_expr resultant(Fmpz_poly_expr)
Fmpz_expr content(Fmpz_poly_expr)

Fmpz_poly_expr div_basecase(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr div_divconquer(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr rem_basecase(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr pseudorem_cohen(Fmpz_poly_expr, Fmpz_poly_expr)

void divrem(Fmpz_poly_target Q, Fmpz_poly_target R, Fmpz_poly_expr A,
        Fmpz_poly_expr B)
void divrem_basecase(Fmpz_poly_target Q, Fmpz_poly_target R, Fmpz_poly_expr A,
        Fmpz_poly_expr B)
void divrem_divconquer(Fmpz_poly_target Q, Fmpz_poly_target R,
        Fmpz_poly_expr A, Fmpz_poly_expr B)

void pseudo_divrem(Fmpz_poly_target Q, Fmpz_poly_target R,
        ulong& d, Fmpz_poly_expr A, Fmpz_poly_expr B)
void pseudo_divrem_basecase(Fmpz_poly_target Q, Fmpz_poly_target R,
        ulong& d, Fmpz_poly_expr A, Fmpz_poly_expr B)
void pseudo_divrem_divconquer(Fmpz_poly_target Q, Fmpz_poly_target R,
        ulong& d, Fmpz_poly_expr A, Fmpz_poly_expr B)
void pseudo_divrem_cohen(Fmpz_poly_target Q, Fmpz_poly_target R, Fmpz_poly_expr A,
        Fmpz_poly_expr B)

fmpz_polyxx pseudo_div(ulong& d, Fmpz_poly_expr A, Fmpz_poly_expr B)
fmpz_polyxx pseudo_rem(ulong& d, Fmpz_poly_expr A, Fmpz_poly_expr B)

bool poly_divides(Fmpz_poly_target Q, Fmpz_poly_expr A, Fmpz_poly_expr B)

Fmpz_poly_expr div_root(Fmpz_poly_expr, Fmpz_expr)

Fmpz_poly_expr inv_series_newton(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr inv_series(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr div_series(Fmpz_poly_expr, Fmpz_poly_expr, slong n)

Fmpz_poly_expr derivative(Fmpz_poly_expr)

Fmpz_poly_expr compose(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr compose_horner(Fmpz_poly_expr, Fmpz_poly_expr)
Fmpz_poly_expr compose_divconquer(Fmpz_poly_expr, Fmpz_poly_expr)

fmpz_polyxx compose_series(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx compose_series_horner(Fmpz_poly_expr, Fmpz_poly_expr, slong)
fmpz_polyxx compose_series_brent_kung(Fmpz_poly_expr, Fmpz_poly_expr, slong)

Fmpz_expr evaluate(Fmpz_poly_expr, Fmpz_expr)
Fmpz_vec_expr evaluate(Fmpz_poly_expr, Fmpz_vec_expr)
Fmpz_expr evaluate_horner(Fmpz_poly_expr, Fmpz_expr)
Fmpz_expr evaluate_divconquer(Fmpz_poly_expr, Fmpz_expr)

mp_limb_t evaluate_mod(Fmpz_poly_expr p, mp_limb_t x, mp_limb_t n)

Fmpz_poly_expr taylor_shift(Fmpz_poly_expr, Fmpz_expr)
Fmpz_poly_expr taylor_shift_horner(Fmpz_poly_expr, Fmpz_expr)
Fmpz_poly_expr taylor_shift_divconquer(Fmpz_poly_expr, Fmpz_expr)

Fmpz_poly_expr revert_series(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr revert_series_newton(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr revert_series_lagrange(Fmpz_poly_expr, T:fits_into_slong)
Fmpz_poly_expr revert_series_lagrange_fast(Fmpz_poly_expr, T:fits_into_slong)

Fmpz_poly_expr sqrt(Fmpz_poly_expr p)
Fmpz_poly_expr sqrt_classical(Fmpz_poly_expr p)

    Compute the square root of \code{p}, provided \code{p} is a perfect square.
    Else raise \code{flint_exception}. See \code{fmpz_poly_sqrt}.

Fmpz_expr poly_bound_roots(Fmpz_poly_expr p)



*******************************************************************************

    fmpq\_polyxx

*******************************************************************************

fmpq_polyxx::fmpq_polyxx()

fmpq_polyxx::fmpq_polyxx(slong alloc)

    See \code{fmpq_poly_init2}.

static fmpq_polyxx fmpq_polyxx::randtest(
        frandxx& state, slong len, mp_bitcnt_t bits)
static fmpq_polyxx fmpq_polyxx::randtest_unsigned(
        frandxx& state, slong len, mp_bitcnt_t bits)
static fmpq_polyxx fmpq_polyxx::randtest_not_zero(
        frandxx& state, slong len, mp_bitcnt_t bits)

    See \code{fmpq_poly_randtest} etc.

static fmpq_polyxx fmpq_polyxx::get_slice(Fmpq_poly_expr, slong i, slong j)

static Fmpq_poly_expr fmpq_polyxx::interpolate(
        Fmpz_vec_expr xs, Fmpz_vec_expr ys)

    See \code{fmpq_poly_interpolate_fmpq_vec}.

void Fmpq_poly_target realloc(slong alloc)
void Fmpq_poly_target::fit_length(slong len)
void Fmpq_poly_target::_normalise()
void Fmpq_poly_target::_set_length(slong len)
void Fmpq_poly_target::canonicalise()
bool Fmpq_poly_src::is_canonical() const

fmzqxx_ref Fmpq_poly_target::get_coeff_numref(slong n)
fmzqxx_srcref Fmpq_poly_src::get_coeff_numref(slong n) const

    Obtain a reference to the numerator of coefficient $n$.
    The result is undefined if $n$ is
    greater than the degree of the polynomial (or negative).

fmpqxx_ref Fmpq_poly_target::denref()
fmpqxx_srcref Fmpq_poly_src::denref() const

    Obtain a reference to the denominator of the polynomial.

void Fmpq_poly_target::set_coeff(slong n, Fmpz_expr)
void Fmpq_poly_target::set_coeff(slong n, Fmpq_expr)
void Fmpq_poly_target::set_coeff(slong n, T:is_integer)

slong Fmpq_poly_expr::length() const
slong Fmpq_poly_expr::degree() const
bool Fmpq_poly_expr::is_one() const
bool Fmpq_poly_expr::is_zero() const
bool Fmpq_poly_expr::is_monic() const
bool Fmpq_poly_expr::is_squarefree() const
fmpqxx Fmpq_poly_expr::get_coeff(slong n) const

std::string Fmpq_poly_expr::pretty(const char* x) const

    See \code{fmpq_poly_get_str_pretty}.

std::string Fmpq_poly_expr::to_string() const

Fmpq_poly_expr Fmpq_poly_expr::operator()(Fmpq_poly_expr) const
Fmpq_poly_expr Fmpq_poly_expr::operator()(Fmpq_expr) const

    Overloaded \code{operator()} for evaluation or composition.

Fmpq_expr::unary operation() const

    The following unary functions are made available as member functions:
    \code{derivative}, \code{integral}, \code{inv}, \code{make_monic},
    \code{primitive_part}, \code{content}.

Fmpq_expr::binary operation(??) const

    The following binary functions are made available as member functions:
    \code{asinh_series), \code{asin_series}, \code{atanh_series},
    \code{atan_series}, \code{cosh_series}, \code{cos_series}, \code{divrem},
    \code{exp_series}, \code{gcd}, \code{inv_series}, \code{inv_series_newton},
    \code{lcm}, \code{log_series}, \code{pow}, \code{resultant},
    \code{reverse}, \code{revert_series}, \code{revert_series_lagrange},
    \code{revert_series_lagrange_fast}, \code{revert_series_newton},
    \code{sinh_series}, \code{tanh_series}, \code{tan_series}, \code{xgcd}.

Fmpq_poly_expr Fmpq_poly_expr::rescale(Fmpq_expr) const

    See \code{poly_rescale}.

Fmpq_poly_expr Fmpq_poly_expr::shift_left(T:fits_into_slong) const

    See \code{poly_shift_left}.

Fmpq_poly_expr Fmpq_poly_expr::shift_right(T:fits_into_slong) const

    See \code{poly_shift_right}.

Fmpq_expr::ternary operation(??, ??) const

    The following ternary functions are made available as member functions:
    \code{compose_series}, \code{compose_series_brent_kung},
    \code{compose_series_horner}, \code{div_series}, \code{mullow}.

Fmpq_poly_target Fmpq_poly_target::operator=(T:is_integer)
Fmpq_poly_target Fmpq_poly_target::operator=(Fmpq_expr)
Fmpq_poly_target Fmpq_poly_target::operator=(Fmpz_expr)
Fmpq_poly_target Fmpq_poly_target::operator=(Fmpz_poly_expr)
Fmpq_poly_target Fmpq_poly_target::operator=(const char*)

Fmpq_poly_expr operator?(??, ??)

    Arithmetic operators \code{+ - * /} are overloaded if both arguments are
    polynomials, or one poylnomial and one \code{Fmpq_expr}, \code{Fmpz_expr}
    or integer.

bool operator??(Fmpq_poly_expr, Fmpq_poly_expr)

    Relational operators \code{>= > <= < == !=} are overloaded, see
    \code{fmpq_poly_cmp}.

Fmpq_poly_expr operator%(Fmpq_poly_expr, Fmpq_poly_expr)

    See \code{fmpq_poly_rem}.

Fmpq_poly_expr operator-(Fmpq_poly_expr)

Fmpq_poly_expr inv(Fmpq_poly_expr)

Fmpq_poly_expr reverse(Fmpq_poly_expr, T:fits_into_slong)

fmpq_polyxx mullow(Fmpq_poly_expr, Fmpq_poly_expr, slong)

Fmpq_poly_expr pow(Fmpq_poly_expr, T:is_unsigned_integer)

Fmpq_poly_expr poly_shift_left(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr poly_shift_right(Fmpq_poly_expr, T:fits_into_slong)

Fmpq_poly_expr gcd(Fmpq_poly_expr, Fmpq_poly_expr)
Fmpq_poly_expr lcm(Fmpq_poly_expr, Fmpq_poly_expr)

fmpqxx xgcd(Fmpq_poly_target r, Fmpq_poly_target s, Fmpq_poly_expr f,
        Fmpq_poly_expr g)

Fmpq_expr resultant(Fmpq_poly_expr)

void divrem(Fmpq_poly_target Q, Fmpq_poly_target R, Fmpq_poly_expr A,
        Fmpq_poly_expr B)

bool poly_divides(Fmpq_poly_target Q, Fmpq_poly_expr A, Fmpq_poly_expr B)

Fmpq_poly_expr inv_series_newton(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr inv_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr div_series(Fmpq_poly_expr, Fmpq_poly_expr, slong n)

Fmpq_poly_expr derivative(Fmpq_poly_expr)

Fmpq_poly_expr compose(Fmpq_poly_expr, Fmpq_poly_expr)

fmpq_polyxx compose_series(Fmpq_poly_expr, Fmpq_poly_expr, slong)
fmpq_polyxx compose_series_horner(Fmpq_poly_expr, Fmpq_poly_expr, slong)
fmpq_polyxx compose_series_brent_kung(Fmpq_poly_expr, Fmpq_poly_expr, slong)

Fmpq_expr evaluate(Fmpq_poly_expr, Fmpq_expr)
Fmpq_expr evaluate(Fmpq_poly_expr, Fmpz_expr)

Fmpq_poly_expr poly_rescale(Fmpq_poly_expr, Fmpq_expr)

Fmpq_poly_expr make_monic(Fmpq_poly_expr)

Fmpq_poly_expr revert_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr revert_series_newton(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr revert_series_lagrange(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr revert_series_lagrange_fast(Fmpq_poly_expr, T:fits_into_slong)

Fmpq_poly_expr sqrt_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr invsqrt_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr exp_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr log_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr atan_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr atanh_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr asin_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr asinh_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr tan_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr sin_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr cos_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr sinh_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr cosh_series(Fmpq_poly_expr, T:fits_into_slong)
Fmpq_poly_expr tanh_series(Fmpq_poly_expr, T:fits_into_slong)



*******************************************************************************

    fmpz\_poly\_qxx

*******************************************************************************

fmpz_poly_qxx::fmpz_poly_qxx()

static fmpz_poly_qxx fmpz_poly_qxx::randtest(frandxx& state,
        slong len1, mp_bitcnt_t bits1, slong len2, mp_bitcnt_t bits2)
static fmpz_poly_qxx fmpz_poly_qxx::randtest_not_zero(frandxx& state,
        slong len1, mp_bitcnt_t bits1, slong len2, mp_bitcnt_t bits2)

    See \code{fmpz_poly_q_randtest} etc.

void Fmpz_poly_q_target::canonicalise()
bool Fmpz_poly_q_src::is_canonical() const

fmpz_polyxx_ref Fmpz_poly_q_target::get_numref()
fmz_polyxx_srcref Fmpz_poly_q_src::get_numref() const
fmpz_polyxx_ref Fmpz_poly_q_target::get_denref()
fmz_polyxx_srcref Fmpz_poly_q_src::get_denref() const

    Obtain a reference to the numerator or denominator of the rational
    function.

bool Fmpz_poly_q_expr::is_one() const
bool Fmpz_poly_q_expr::is_zero() const

std::string Fmpz_poly_q_expr::pretty(const char* x) const

    See \code{fmpz_poly_q_get_str_pretty}.

std::string Fmpz_poly_q_expr::to_string() const

Fmpz_poly_q_expr Fmpz_poly_q_expr::inv() const
Fmpz_poly_q_expr Fmpz_poly_q_expr::derivative() const
Fmpz_poly_q_expr Fmpz_poly_q_expr::pow(T:is_unsigned_integer) const

Fmpz_poly_q_target Fmpz_poly_q_target::operator=(T:fits_into_slong)
Fmpz_poly_q_target Fmpz_poly_q_target::operator=(const char*)

Fmpz_poly_q_expr operator?(??, ??)

    Arithmetic operators \code{+ - * /} are overloaded if both arguments are
    functions.

bool operator==(Fmpz_poly_q_expr, Fmpz_poly_q_expr)

Fmpz_poly_q_expr operator-(Fmpz_poly_q_expr)

Fmpz_poly_q_expr inv(Fmpz_poly_q_expr)

Fmpz_poly_q_expr pow(Fmpz_poly_q_expr, T:is_unsigned_integer)

Fmpz_poly_q_expr derivative(Fmpz_poly_q_expr)




*******************************************************************************

    padicxx

    The type \code{padicxx} wraps the C interface \code{padic_t}, and the type
    \code{padicxx_ctx} wraps \code{padic_ctx_t}.

    Evaluating composite expressions requires temporary objects, which must be
    initialised to a certain precision and with a certain context. The padicxx
    library employs the following rules:

    \begin{itemize}
      \item In any compound expression, there must only be one context involved.
      \item Temporary objects are initialised to the maximum precision of any
            subexpression.
    \end{itemize}

*******************************************************************************

padicxx_ctx::padicxx_ctx(Fmpz_src p, long min, long max, padic_print_mode mode)

    Initialize a padic context. See \code{padic_ctx_init}.

padic_ctx_t& padicxx_ctx::_ctx() const

    Obtain a reference to the underlying C data structure.
    Note that this reference is mutable even if the instance of
    \code{padicxx_ctx} it
    is obtained from is not. This is because the context contains data which is
    not user-visible, and the C functions change them.

    If this is called on a constant instance of \code{padicxx_ctx}, you must
    ensure that no user-visible state is changed.

padicxx::padicxx(const padicxx_ctx&)

    Initialize padic number to default precision. See \code{padic_init}.

padicxx::padicxx(const padicxx_ctx& c, long N)

    Initialize padic number to precision $N$. See \code{padic_init2}.

static padicxx padicxx::randtest(frandxx& state, const padicxx_ctx& ctx,
        slong prec = PADIC_DEFAULT_PREC)

static padicxx padicxx::randtest_int(frandxx& state, const padicxx_ctx& ctx,
        slong prec = PADIC_DEFAULT_PREC)

static padicxx padicxx::randtest_not_zero(frandxx& state,
        const padicxx_ctx& ctx, slong prec = PADIC_DEFAULT_PREC)

    Obtain a random padic number of precision \code{prec}. See
    \code{padic_randtest}, \code{padic_randtest_int} and
    \code{padic_randtest_not_zero}.

static padicxx_ref fmpzxx_ref::make(padic* f)
static padicxx_srcref fmpzxx_srcref::make(const padic* f)

    Obtain a flintxx reference object pointing to \code{*f}. Here \code{f} must
    not be zero.

padic* Padic_target::_padic()
const padic* Padic_src::_padic() const

    Obtain a reference to the underlying C data type.

const padicxx_ctx& Padic_src::get_ctx() const
padic_ctx_t& Padic_src::_ctx() const

    Obtain a reference to the context of this instance.

slong Padic_src::_prec() const

    Obtain the precision of this instance. See \code{padic_prec}.

void Padic_target::reduce()

    See \code{padic_reduce}.

fmpzxx_ref Padic_target::unit()
fmpzxx_srcref Padic_src::unit() const

    See \code{padic_unit}.

slong Padic_expr::prec() const

    Compute the maximum precision of any subexpression.

const padicxx_ctx& Padic_expr::estimate_ctx() const

    Obtain a reference to a context occurring in a subexpression. As per the
    first rule in the introduction to this section, all such contexts are the
    same by definition.

bool Padic_expr::is_zero() const
bool Padic_expr::is_one() const
slong Padic_expr::val() const

fmpzxx Padic_expr::to<fmpzxx>() const

    Convert self to \code{fmpzxx}, if possible. See \code{padic_get_fmpz}.

fmpqxx Padic_expr::to<fmpqxx>() const

    Convert self to \code{fmpqxx}. See \code{padic_get_fmpz}.

std::string Fmpz_expr::to_string() const

Padic_expr::unary operation() const

    The following unary functions are made available as member functions:
    \code{exp}, \code{exp_balanced}, \code{exp_rectangular}, \code{inv},
    \code{log}, \code{log_balanced}, \code{log_satoh}, \code{sqrt},
    \code{teichmuller}.

Padic_expr Padic_expr::pow(T:fits_into_slong) const

Padic_target Padic_target::operator=(T:is_integer)
Padic_target Padic_target::operator=(Fmpz_expr)
Padic_target Padic_target::operator=(Fmpq_expr)

bool operator==(Padic_expr, Padic_expr)

Padic_expr operator??(Padic_expr, Padic_expr)

    Arithmetic operators \code{+ - * /} are overloaded for padic expressions.

Padic_expr operator<<(Padic_expr, T:fits_into_slong)
Padic_expr operator>>(Padic_expr, T:fits_into_slong)

    Shift operators are overloaded.

Padic_expr operator-(Padic_expr)

Padic_expr sqrt(Padic_expr)

    Compute square root. May raise \code{flint_exception} if no square root
    exists. See \code{padic_sqrt}.

Padic_expr pow(Padic_expr, T:fits_into_slong)

Padic_expr exp(Padic_expr)
Padic_expr exp_rectangular(Padic_expr)
Padic_expr exp_balanced(Padic_expr)
Padic_expr log(Padic_expr)
Padic_expr log_rectangular(Padic_expr)
Padic_expr log_balanced(Padic_expr)
Padic_expr log_satoh(Padic_expr)

    Compute special functions. These may raise \code{flint_exceptions}.

Padic_expr inv(Padic_expr)

Padic_expr teichmuller(Padic_expr)

Fmpz_expr padic_val_fac(Fmpz_expr, Fmpz_expr)
ulong padic_val_fac(T:is_unsigned_integer, Fmpz_expr)
