/*=============================================================================
vim: spell spelllang=en textwidth=79

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2013 Tom Bachmann

******************************************************************************/

*******************************************************************************

    Rules and standard methods

    A typical expression template class begins with the following lines of code:

    \begin{lstlisting}[language=c++]
    template<class Operation, class Data>
    class some_expression
        : public expression<derived_wrapper<some_expression>, Operation, Data>
    {
        // ...
    };
    \end{lstlisting}

    We document here methods this class inherits from its base, and how they
    relate to rules.

    There are the following public typedefs:

    \begin{description}
    \item[ev\_traits\_t] A specialisation of \code{detail::evaluation_traits}.
        Used to compute the rule for evaluation.
    \item[derived\_t] The specialised derived class.
    \item[evaluated\_t] The resulting type of evaluating this expression.
    \item[evaluation\_return\_t] The return type of \code{evaluate()}. This
        differs from the above for immediates, where evaluation returns a
        reference instead of a copy.
    \item[data\_t] The same as \code{Data}.
    \item[operation\_t] The same as \code{Operation}.
    \end{description}

*******************************************************************************
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Standard methods
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

data_t& some_expression::_data()
const data_t& some_expression::_data() const

    Obtain the data related to this expression template.

evaluated_t some_expression::create_temporary() const

    Default instantiate a temporary. Override this if your class is not default
    instantiable.

template<class T> T some_expression::to() const

    Convert self to type \code{T} (after evaluating). Uses
    \code{rules::conversion}.

void some_expression::print(std::ostream& o) const

    Print self to \code{o}. Uses \code{rules::print} or
    \code{rules::to_string}.

int some_expression::print(FILE* f = stdout) const

    Print self to \code{f}. Uses \code{rules::cprint}.

int some_expression::print_pretty(FILE* f = stdout) const

    Print self to \code{f}. Uses \code{rules::print_pretty}.

template<class T> int some_expression::print_pretty(const T& extra,
        FILE* f = stdout) const

    Print self to \code{f}. Uses \code{rules::print_pretty} with two arguments.

int some_expression::read(FILE* f = stdin)

    Read self from \code{f}. Uses \code{rules::read}.

const evaluation_return_t some_expression::evaluate() const

    Evaluate self.

template<class T> void some_expression::set(const T& t)

    Assign \code{t} to self. Uses evaluation and/or \code{rules::assignment}.

template<class T> bool some_expression::equals(const T& t) const

    Determine if \code{t} is equal to self. Uses \code{rules::equals} or
    \code{rules::cmp}.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Global functions

    In addition to member functions, flintxx also provides a number of global
    functions. In general these operate on sets of arguments at least one of
    which derives from \code{expression}, and are conditionally enabled only if
    the relevant operation is implemented (via a rule).
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

template<class Expr> std::ostream& operator<<(std::ostream& o, const Expr& e)

    Print \code{e} to \code{o}. Uses the member \code{print}.

template<class Expr1, class Expr2> bool operator==(const Expr1&, const Expr2&)
template<class Expr1, class Expr2> bool operator!=(const Expr1&, const Expr2&)

    Compare two expressions. Uses the member \code{equals}.

template<class Expr1, class Expr2> bool operator??(const Expr1&, const Expr2&)

    Relational operators \code{< > <= =>} are implemented using
    \code{rules::cmp}.

template<class Expr1, class Expr2> ?? operator??(const Expr1&, const Expr2&)

    Arithmetic operators \code{+ - * / % & | ^ << >>} are implemented
    by constructing new expression templates with operation
    \code{operations::plus} etc.

template<class Expr1> ?? operator??(const Expr1&)

    Unary operators \code{- ~} are implemented by constructing new expression
    templates with operation \code{operations::negate} and
    \code{operations::complement}.

template<class Expr1, class Expr2> ?? operator?=(const Expr1&, const Expr2&)

    Arithmetic-assignment operators \code{+= -= *= /= %= |= &= ^=}.

template<class Expr1> int print(const Expr1&)
template<class Expr1> int print(FILE*f, const Expr1&)
template<class Expr1> int print_pretty(const Expr1&)
template<class Expr1> int print_pretty(FILE*f, const Expr1&)
template<class Expr1, class T> int print_pretty(const Expr1&, const T& extra)
template<class Expr1, class T> int print_pretty(FILE*f, const Expr1&,
        const T& extra)

    Forward to member.

template<class Expr1, class Expr2> void swap(Expr1& e1, Expr2& e2)

    Swap \code{e1} and \code{e2} using \code{rules::swap}. Note that via ADL,
    this can be used by STL containers.


*******************************************************************************

    Convenience macros

*******************************************************************************

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    flintxx/rules.h
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FLINT_DEFINE_GET2(name, totype, fromtype1, fromtype2, eval)

    Speciallise a getter called \code{name}, which takes arguments \code{e1} of
    type \code{fromtype1} and \code{e2} of type \code{fromtype2}. It returns
    \code{totype} by executing \code{eval}.

FLINT_DEFINE_GET(name, totype, fromtype, eval)

    Same as \code{FLINT_DEFINE_GET2(name, totype, fromtype, fromtype, eval)}.

FLINT_DEFINE_GET_COND(name, totye, cond, eval)

    Specialise a getter called \code{name}, which takes an argument \code{from}
    of type \code{T:cond} It returns \code{totype} by
    executing \code{eval}.

FLINT_DEFINE_DOIT(name, totype, fromtype, eval)

    Specialise a doit rule called \code{name}, which takes arguments
    \code{to} of type \code{totype&} and \code{from} of type
    \code{const fromtype&}, and executes \code{eval}.

FLINT_DEFINE_DOIT_COND(name, totype, cond, eval)

    Same as above, but takes \code{const T& from} for any \code{T:cond}.

FLINT_DEFINE_DOIT_COND2(name, cond1, cond2, eval)

    Same as \code{FLINT_DEFINE_DOIT_COND}, but takes \code{T& to} and
    \code{const U& from} for any \code{T} satisfying \code{cond1<T>} and
    \code{U} satisfying \code{cond2<U>}.

FLINT_DEFINE_PRINT_COND(cond, eval)

    Specialise the \code{cprint} rule. This takes a arguments \code{FILE* to}
    and \code{const T& from} for any \code{T:cond}. It
    prints \code{from} to \code{to} and returns \code{int} by executing
    \code{eval}.

FLINT_DEFINE_PRINT_PRETTY_COND(cond, eval)

    Same as above, but with \code{print_pretty} instead of \code{cprint}.

FLINT_DEFINE_PRINT_PRETTY_COND2(cond, extratype, eval)

    Same as above, but takes an additional argument \code{extratype extra}.
    Useful e.g. when printing polynomials and taking an extra variable name.

FLINT_DEFINE_READ_COND(cond, eval)

    Specialise the \code{read} rule. This takes a arguments \code{FILE* from}
    and \code{T& to} for any \code{T:cond}. It
    reads \code{to} from \code{from} and returns \code{int} by executing
    \code{eval}.

FLINT_DEFINE_UNARY_EXPR_(name, rtype, type, eval)

    Specialise the unary expression rule for \code{operations::name} with
    nominal return type \code{rtype}. It takes
    arguments \code{V& to} and \code{const type& from}. Here \code{V} is any
    type which \code{rtype} can be evaluated into. Executes \code{eval}.

FLINT_DEFINE_UNARY_EXPR(name, type, eval)

    Same as \code{FLINT_DEFINE_UNARY_EXPR_(name, type, type, eval)}.

FLINT_DEFINE_BINARY_EXPR2(name, rtype, type1, type2, eval)

    Specialise the binary expression rule for \code{operations::name} of
    nominal return type \code{rtype}, and arguments \code{type1} and
    \code{type2}.

FLINT_DEFINE_BINARY_EXPR(name, type, eval)

    Same as \code{FLINT_DEFINE_BINARY_EXPR2(name, type, type, type, eval)}.

FLINT_DEFINE_CBINARY_EXPR(name, type, eval)

    Same as above, but with \code{commutative_binary_expression} instead of
    \code{binary_expression}.

FLINT_DEFINE_BINARY_EXPR_COND(name, type, cond, eval)
FLINT_DEFINE_CBINARY_EXPR_COND(name, type, cond, eval)

    Specialise the (commutative) binary expression rule for
    \code{operations::name} of nominal return type \code{type}, and arguments
    \code{type} and \code{T:cond}.

FLINT_DEFINE_BINARY_EXPR_COND2(name, rettype, cond1, cond2, eval)
FLINT_DEFINE_CBINARY_EXPR_COND2(name, rettype, cond1, cond2, eval)

    Specialise the (commutative) binary expression rule for
    \code{operations::name} of nominal return type \code{rettype}, and arguments
    \code{T:cond1} and \code{U:cond2}.

FLINT_DEFINE_THREEARY_EXPR_COND3(name, rettype, cond1, cond2, cond3, eval)
FLINT_DEFINE_FOURARY_EXPR_COND4(name, retttype, cond1 ... cond4, eval)
FLINT_DEFINE_FIVEARY_EXPR_COND5(name, rettype, cond1 ... cond5, eval)
FLINT_DEFINE_SIXARY_EXPR_COND6(name, rettype, cond1 ... cond6, eval)
FLINT_DEFINE_SEVENARY_EXPR_COND7(name, rettype, cond1 ... cond7, eval)

    Specialise higher order rules, similarly to the above.

FLINT_DEFINE_THREEARY_EXPR(name, retttype, T1, T2, T3, eval)

    Specialise a threeary expression rule unconditionally.
