TODO
====

* in is_prime_pocklington allow the cofactor to be a perfect power not just prime

* make n_gcd take arguments in either order and use throughout flint2

* have make check bomb out if one of the tests aborts

* factor out some common code between n_is_perfect_power235 and n_factor_power235

* add profile code for factor_trial, factor_one_line, factor_SQUFOF

* Use fmpz_init and fmpz_clear in the t-fmpz test

* Write a flint2 memory manager, both reentrant and non-reentrant stack based versions

* Write a configure script for flint2 which has an option for reentrant/non-reentrant

* fmpz_single currently hangs on to all mpz's. It might be better to release ones that are 
  over a certain size (careful, checking every single one might be expensive. It might be
  better to have some kind of garbage collection; then again checking whether the garbage
  collection needs to be run every time also costs time, though a garbage collector can do
  more).

* Implement a z_randtest() function and use in fmpz_get/set_si 

* Implement a long_extras module and use z_gcd and z_invert in fmpz_gcd and fmpz_invert, 
  respectively

* Write test code for fmpz_poly_scalar_addmul_fmpz

* Write _fmpz_poly_zero/neg/set/scalar_mul_si and use in _fmpz_poly_scalar_addmul_fmpz

Maybe
=====

* make n_factor_t an array of length 1 so it can be passed by reference automatically, as per mpz_t's, etc

* figure out how to write robust test code for fmpz_read (which reads from stdin), perhaps using a pipe.

Enhancements
============

* Implement a primality test which only requires factoring of n-1 up to n^1/3 or n^1/4

* Implement a combined p-1 and p+1 primality test as per http://primes.utm.edu/prove/prove3_3.html

* Implement a quadratic sieve and use it in n_factor once things get too large for SQUFOF
