TODO
====

* in is_prime_pocklington allow the cofactor to be a perfect power not just prime

* make n_gcd take arguments in either order and use throughout flint2

* have make check bomb out if one of the tests aborts

* factor out some common code between n_is_perfect_power235 and n_factor_power235

* add profile code for factor_trial, factor_one_line, factor_SQUFOF

* Use fmpz_init and fmpz_clear in the t-fmpz test

* Write a flint2 memory manager, both reentrant and non-reentrant stack based versions

* Write a configure script for flint2 which has an option for reentrant/non-reentrant

* fmpz_single currently hangs on to all mpz's. It might be better to release ones that are 
  over a certain size (careful, checking every single one might be expensive. It might be
  better to have some kind of garbage collection; then again checking whether the garbage
  collection needs to be run every time also costs time, though a garbage collector can do
  more).

* Implement a z_randtest() function and use in fmpz_get/set_si 

* Implement a long_extras module and use z_gcd and z_invert in fmpz_gcd and fmpz_invert, 
  respectively

* Write test code for fmpz_poly_scalar_addmul_fmpz

* Write test code for fmpz_vec functions

* get rid of global random states

* add fmpz_mat/randajtai2.c based on Stehle's matrix.cpp in fpLLL (requires mpfr_t's).

* add a cache of mpfr's which can be used as temporaries for functions like _mpfr_vec_scalar_product

* test code for ulong_extras/revbin.c

* add test code for numerous mpfr_vec functions and mpfr_poly_mul_classical

* make use of mpfr type througout LLL, mpfr_vec and mpfr_mat modules

* Write fmpz_mpoly_max_bits, use in t-mul_heap test code and mul_heap

* Write ACCUM2 and ACCUM3 assembly functions and use in mul_heap

* Make mul_heap take arrays of fmpz's as arguments and document function

* Write some macros for modular reduction in the nmod_poly module.

* Make some assembly optimisations to nmod_poly module.

* add test code for fmpz_poly_max_limbs

* Fix a bug in mul_KS and mullow_KS, to do with the assumption len1 >= len2 
  and zero padding

* Check and improve the functions fmpz_sizeinbase, fmpz_get_str and 
  fmpz_set_str, which in a first adhoc implementation only wrap the GMP/ MPIR 
  functionality.  Once this has been done, also include test code for these

* Improve the implementations of fmpz_poly_divrem, _div, and _rem, check that 
  the documentations still apply, and write test code for this --- all of this 
  makes more sense once there is a choice of algorithms

Maybe
=====

* make n_factor_t an array of length 1 so it can be passed by reference automatically, as per mpz_t's, etc

* figure out how to write robust test code for fmpz_read (which reads from stdin), perhaps using a pipe

* a type mpfr which is an alias for __mpfr_struct and using throughout

Enhancements
============

* Implement a primality test which only requires factoring of n-1 up to n^1/3 or n^1/4

* Implement a combined p-1 and p+1 primality test as per http://primes.utm.edu/prove/prove3_3.html

* Implement a quadratic sieve and use it in n_factor once things get too large for SQUFOF
