/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 Fredrik Johansson

******************************************************************************/

This module implements arithmetic functions, number-theoretic and combinatorial
special number sequences and polynomials.



*******************************************************************************

    Factoring integers 

*******************************************************************************

void fmpz_factor_init(fmpz_factor_t factor)
void fmpz_factor_clear(fmpz_factor_t factor)

    An integer may be represented in factored form using the fmpz_factor_t
    data structure. This consists of two fmpz vectors representing
    bases and exponents respectively. Canonically, the bases will be
    prime numbers sorted in ascending order and the exponents will be
    positive.

    A separate int field holds the sign, which may be -1, 0 or 1.


void fmpz_factor(fmpz_factor_t factor, const fmpz_t n)

    Factors n into prime numbers. If n is zero or negative, the
    sign field of the factor object will be set accordingly.

    This currently only uses trial division, falling back to n_factor
    as soon as the number shrinks to a single limb.


void fmpz_unfactor(fmpz_t n, const fmpz_factor factor)

    Evaluates an integer in factored form back to an fmpz_t.

    This currently exponentiates the bases separately and multiplies
    them together one by one, although much more efficient algorithms
    exist. 


*******************************************************************************

    Special numbers

*******************************************************************************

void fmpz_primorial(fmpz_t res, long n)

    Sets res to "n primorial" or "n#", the product of all prime numbers less
    than or equal to n.

void mpq_harmonic(mpq_t res, long n)

    Sets res to the nth harmonic number H_n = 1 + 1/2 + 1/3 + ... + 1/n.
    The result is zero if n <= 0.

    Table lookup is used for H_n whose numerator and denomator fit in
    single limb. For larger n, mpn_harmonic_odd_balanced is used.


*******************************************************************************

    Multiplicative functions

*******************************************************************************

void fmpz_euler_phi(fmpz_t res, const fmpz_t n)

    Sets res to the Euler totient function phi(n), counting the number of
    positive integers less than or equal to n that are coprime to n.


int fmpz_moebius_mu(const fmpz_t n)

   Computes the Moebius function mu(n) = 0 if n has a prime factor of
   multiplicity greater than 1, mu(n) = -1 n has an odd number of distinct
   prime factors, mu(n) = 1 if n has an even number of distinct prime factors.
   By convention, mu(0) = 0.


void fmpz_divisor_sigma(fmpz_t res, const fmpz_t n, ulong k)

    Sets res to sigma_k(n), the sum of kth powers of all divisors of n.


void fmpz_divisors(fmpz_poly_t res, const fmpz_t n)

    Set the coefficients of the polynomial res to the divisors of n
    (including 1 and n itself) in ascending order.


void fmpz_ramanujan_tau(fmpz_t res, const fmpz_t n)

    Sets res to the Ramanujan tau function tau(n) which is the coefficient of
    q^n in the series expansion of f(q) = q * prod_{k>=1} (1-q^k)^24.

    We factor n and use the identity tau(p*q) = tau(p)*tau(q)
    along with the recursion tau(p^(r+1)) = tau(p)*tau(p^r) - p^11*tau(p^(r-1))
    for prime powers.

    The base values tau(p) are obtained from fmpz_poly_ramanujan_tau.
    Thus the speed of fmpz_ramanujan_tau depends on the largest
    prime factor of n.

    Future improvement: optimize for small n (could use a lookup table
    or fmpz_poly_ramanujan_tau directly).


void fmpz_poly_ramanujan_tau(fmpz_poly_t res, long n)

    Set res to the the polynomial with coefficients tau(0),tau(1)...tau(n-1)
    giving the initial n terms in the series expansion of
    f(q) = q * prod_{k>=1} (1-q^k)^24.

    The algorithm is borrowed from the delta_qexp function in Sage (written
    by William Stein and David Harvey), and consists of expanding the
    series of the equivalent representation
    f(q) = q * (sum_{k>=0} (-1)^k (2k+1) q^(k(k+1)/2))^8. The first squaring
    is done directly since the polynomial is very sparse at this point.


