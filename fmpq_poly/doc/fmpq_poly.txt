/*============================================================================

    Copyright (C) 2010 Sebastian Pancratz
    Copyright (C) 2010 William Hart

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

===============================================================================*/

********************************************************************************

    Memory management

********************************************************************************

void fmpq_poly_init(fmpq_poly_t poly)

    Initialises the polynomial for use.  The length is set to zero.

void fmpq_poly_init2(fmpq_poly_t poly, const ulong alloc)

    Initialises the polynomial with space for at least alloc coefficients and 
    set the length to zero. The alloc coefficients are all set to zero.

void fmpq_poly_realloc(fmpq_poly_t poly, const ulong alloc)

    Reallocates the given polynomial to have space for alloc coefficients. 
    If alloc is set to zero then the polynomial is cleared and then 
    reinitialised.  If the current length is greater than alloc then poly 
    is first truncated to length alloc.  Note that this might leave the 
    rational polynomial in non-canonical form.

void fmpq_poly_fit_length(fmpq_poly_t poly, const ulong length)

    If length is currently greater that the number of coefficients
    allocated, then the polynomial is reallocated to have space for at
    least length coefficients. No data is lost when calling this 
    function. The function efficiently deals with the case where 
    fit_length is called many times in small increments by at least 
    doubling the number of allocated coefficients when length is larger 
    than the number of coefficients currently allocated.

void _fmpq_poly_set_length(fmpq_poly_t poly, const ulong length)
    
    Sets the length of the numerator polynomial to length, demoting 
    coefficients beyond the new length.  Note that this method does 
    not guarantee that the rational polynomial is in canonical form.

void fmpq_poly_clear(fmpq_poly_t poly)
    
    Clears the given poly, releasing any memory used. The poly must
    be reinitialised in order to be used again.

void _fmpq_poly_normalise(fmpq_poly_t poly)

    Sets the length of poly so that the top coefficient is nonzero.  If 
    all coefficients are zero, the length is set to zero.  Note that 
    this function does not guarantee the coprimality of the numerator 
    polynomial and the integer denominator.

void fmpq_poly_canonicalise(fmpq_poly_t poly)

    Puts the polynomial poly into canonical form.  Firstly, the length is set 
    to the actual length of the numerator polynomial.  For non-zero 
    polynomials, it is then ensured that the numerator and denominator are 
    coprime and that the denominator is positive.  The canonical form of the 
    zero polynomial is a zero numerator polynomial and a one denominator.

*******************************************************************************

    Polynomial parameters

********************************************************************************

long fmpq_poly_degree(fmpq_poly_t poly)

    Returns the degree of poly, which is one less than its length, as a long. 
    Only gives the right answer for polynomials such that the length, which is 
    an unsigned long, fits into a long.

ulong fmpq_poly_length(fmpq_poly_t poly)

    Returns the length of poly.

*******************************************************************************

    Accessing the numerator and denominator

********************************************************************************

fmpz * fmpq_poly_numref(fmpq_poly_t poly)

    Returns a reference to the numerator polynomial as a vector.  Note that 
    this might be NULL.
    
    This is implemented as a macro returning (poly)->coeffs.

fmpz_t fmpq_poly_denref(fmpq_poly_t poly)
    
    Returns a reference to the denominator as a fmpz_t.  The integer is 
    guaranteed to be properly initialised.
    
    This is implemented as a macro returning (poly)->den.

*******************************************************************************

    Assignment, swap, negation

********************************************************************************

void fmpq_poly_set(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to equal poly2.

void fmpq_poly_set_si(fmpq_poly_t poly, const long x)

    Set poly to the integer x.

void fmpq_poly_set_ui(fmpq_poly_t poly, const ulong x)

    Set poly to the integer x.

void fmpq_poly_set_fmpz(fmpq_poly_t poly, const fmpz_t x)

    Set poly to the integer x.

void fmpq_poly_set_mpz(fmpq_poly_t poly, const mpz_t x)

    Set poly to the integer x.

void fmpq_poly_set_mpq(fmpq_poly_t poly, const mpq_t x)

    Set poly to the rational x.

void fmpq_poly_neg(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to the additive inverse of poly2.

void fmpq_poly_inv(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to the multiplicative inverse of poly2 if possible.  Otherwise, 
    if poly2 is not a unit, leaves poly1 unmodified and calls abort().

void fmpq_poly_swap(fmpq_poly_t poly1, fmpq_poly_t poly2)

    Efficiently swaps the polynomials poly1 and poly2.

*******************************************************************************

    Setting and getting coefficients

********************************************************************************

void fmpq_poly_get_coeff_mpq(mpq_t x, const fmpq_poly_t poly, const ulong n)

    Retrieves the nth coefficient of poly.

void fmpq_poly_set_coeff_si(fmpq_poly_t poly, const ulong n, const long x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_ui(fmpq_poly_t poly, const ulong n, const ulong x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_fmpz(fmpq_poly_t poly, const ulong n, const fmpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpz(fmpq_poly_t rop, const ulong n, const mpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpq(fmpq_poly_t rop, const ulong n, const mpq_t x)

    Sets the nth coefficient in poly to the rational x.

********************************************************************************

    Comparison

********************************************************************************

int fmpq_poly_equal(const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Return 1 if poly1 is equal to poly2, otherwise return 0.

int fmpq_poly_cmp(const fmpq_poly_t left, const fmpq_poly_t right)

    Compares the two polynomials left and right.
    
    Compares the two polynomials left and right, returning -1, 0, or 1 as left 
    is less than, equal to, or greater than right.  The comparison is first 
    done by the degree, and then, in case of a tie, by the individual 
    coefficients from highest to lowest.

int fmpq_poly_is_one(const fmpq_poly_t poly)

    Returns 1 if poly is the constant polynomial 1, otherwise returns 0.

int fmpq_poly_is_zero(const fmpq_poly_t poly)

    Returns 1 if poly is the zero polynomial, otherwise returns 0.

