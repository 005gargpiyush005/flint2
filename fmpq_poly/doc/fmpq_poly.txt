/*============================================================================

    Copyright (C) 2010 Sebastian Pancratz
    Copyright (C) 2010 William Hart

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

===============================================================================*/

********************************************************************************

    Memory management

********************************************************************************

void fmpq_poly_init(fmpq_poly_t poly)

    Initialises the polynomial for use.  The length is set to zero.

void fmpq_poly_init2(fmpq_poly_t poly, const ulong alloc)

    Initialises the polynomial with space for at least alloc coefficients and 
    set the length to zero. The alloc coefficients are all set to zero.

void fmpq_poly_realloc(fmpq_poly_t poly, const ulong alloc)

    Reallocates the given polynomial to have space for alloc coefficients. 
    If alloc is set to zero then the polynomial is cleared and then 
    reinitialised.  If the current length is greater than alloc then poly 
    is first truncated to length alloc.  Note that this might leave the 
    rational polynomial in non-canonical form.

void fmpq_poly_fit_length(fmpq_poly_t poly, const ulong length)

    If length is currently greater that the number of coefficients
    allocated, then the polynomial is reallocated to have space for at
    least length coefficients. No data is lost when calling this 
    function. The function efficiently deals with the case where 
    fit_length is called many times in small increments by at least 
    doubling the number of allocated coefficients when length is larger 
    than the number of coefficients currently allocated.

void _fmpq_poly_set_length(fmpq_poly_t poly, const ulong length)
    
    Sets the length of the numerator polynomial to length, demoting 
    coefficients beyond the new length.  Note that this method does 
    not guarantee that the rational polynomial is in canonical form.

void fmpq_poly_clear(fmpq_poly_t poly)
    
    Clears the given poly, releasing any memory used. The poly must
    be reinitialised in order to be used again.

void _fmpq_poly_normalise(fmpq_poly_t poly)

    Sets the length of poly so that the top coefficient is nonzero.  If 
    all coefficients are zero, the length is set to zero.  Note that 
    this function does not guarantee the coprimality of the numerator 
    polynomial and the integer denominator.

void fmpq_poly_canonicalise(fmpq_poly_t poly)

    Puts the polynomial poly into canonical form.  Firstly, the length is set 
    to the actual length of the numerator polynomial.  For non-zero 
    polynomials, it is then ensured that the numerator and denominator are 
    coprime and that the denominator is positive.  The canonical form of the 
    zero polynomial is a zero numerator polynomial and a one denominator.

*******************************************************************************

    Polynomial parameters

********************************************************************************

long fmpq_poly_degree(fmpq_poly_t poly)

    Returns the degree of poly, which is one less than its length, as a long. 
    Only gives the right answer for polynomials such that the length, which is 
    an unsigned long, fits into a long.

ulong fmpq_poly_length(fmpq_poly_t poly)

    Returns the length of poly.

*******************************************************************************

    Accessing the numerator and denominator

********************************************************************************

fmpz * fmpq_poly_numref(fmpq_poly_t poly)

    Returns a reference to the numerator polynomial as a vector.  Note that 
    this might be NULL.
    
    This is implemented as a macro returning (poly)->coeffs.

fmpz_t fmpq_poly_denref(fmpq_poly_t poly)
    
    Returns a reference to the denominator as a fmpz_t.  The integer is 
    guaranteed to be properly initialised.
    
    This is implemented as a macro returning (poly)->den.

********************************************************************************

    Random testing

********************************************************************************

void fmpq_poly_randinit(void)

    Initialise the random state for random polynomial generation.  One should 
    not call this function if fmpz_randinit has already been called. 

void fmpq_poly_randclear(void)

    Clear the random state initialised with fmpq_poly_randinit.  One should 
    not call this function if fmpz_randclear has already been called.

void fmpq_poly_randtest(fmpq_poly_t f, ulong length, mp_bitcnt_t bits_in)

    Sets f to a random polynomial with coefficients up to the given length 
    and where each coefficient has up to the given number of bits.  The 
    coefficients are signed randomly.  One must call fmpq_poly_randinit 
    before calling this function.

void fmpq_poly_randtest_unsigned(fmpq_poly_t f, ulong length, mp_bitcnt_t bits_in)

    Sets f to a random polynomial with coefficients up to the given length 
    and where each coefficient has up to the given number of bits.  One must 
    call fmpq_poly_randinit before calling this function.

void fmpq_poly_randtest_not_zero(fmpq_poly_t f, ulong length, mp_bitcnt_t bits_in)

    As for fmpq_poly_randtest except that length and bits_in may not be
    zero and the polynomial generated is guaranteed not to be the 
    zero polynomial.  One must call fmpq_poly_randinit before calling
    this function.

*******************************************************************************

    Assignment, swap, negation

********************************************************************************

void fmpq_poly_set(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to equal poly2.

void fmpq_poly_set_si(fmpq_poly_t poly, const long x)

    Set poly to the integer x.

void fmpq_poly_set_ui(fmpq_poly_t poly, const ulong x)

    Set poly to the integer x.

void fmpq_poly_set_fmpz(fmpq_poly_t poly, const fmpz_t x)

    Set poly to the integer x.

void fmpq_poly_set_mpz(fmpq_poly_t poly, const mpz_t x)

    Set poly to the integer x.

void fmpq_poly_set_mpq(fmpq_poly_t poly, const mpq_t x)

    Set poly to the rational x.

void fmpq_poly_neg(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to the additive inverse of poly2.

void fmpq_poly_inv(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Set poly1 to the multiplicative inverse of poly2 if possible.  Otherwise, 
    if poly2 is not a unit, leaves poly1 unmodified and calls abort().

void fmpq_poly_swap(fmpq_poly_t poly1, fmpq_poly_t poly2)

    Efficiently swaps the polynomials poly1 and poly2.

*******************************************************************************

    Setting and getting coefficients

********************************************************************************

void fmpq_poly_get_coeff_mpq(mpq_t x, const fmpq_poly_t poly, const ulong n)

    Retrieves the nth coefficient of poly.

void fmpq_poly_set_coeff_si(fmpq_poly_t poly, const ulong n, const long x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_ui(fmpq_poly_t poly, const ulong n, const ulong x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_fmpz(fmpq_poly_t poly, const ulong n, const fmpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpz(fmpq_poly_t rop, const ulong n, const mpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpq(fmpq_poly_t rop, const ulong n, const mpq_t x)

    Sets the nth coefficient in poly to the rational x.

********************************************************************************

    Comparison

********************************************************************************

int fmpq_poly_equal(const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Return 1 if poly1 is equal to poly2, otherwise return 0.

int fmpq_poly_cmp(const fmpq_poly_t left, const fmpq_poly_t right)

    Compares the two polynomials left and right.
    
    Compares the two polynomials left and right, returning -1, 0, or 1 as left 
    is less than, equal to, or greater than right.  The comparison is first 
    done by the degree, and then, in case of a tie, by the individual 
    coefficients from highest to lowest.

int fmpq_poly_is_one(const fmpq_poly_t poly)

    Returns 1 if poly is the constant polynomial 1, otherwise returns 0.

int fmpq_poly_is_zero(const fmpq_poly_t poly)

    Returns 1 if poly is the zero polynomial, otherwise returns 0.

*******************************************************************************

    Arithmetic operations

*******************************************************************************

void _fmpq_poly_add_in_place(fmpz * rpoly, fmpz_t rden, ulong rlen, 
                          const fmpz * poly, const fmpz_t den, const ulong len)

    Forms {rpoly, rden} = {den rpoly + rden poly, den rden}, placing the 
    result into canonical form, that is, the denominator is a positive 
    denominator, which is co-prime to the content of the numerator vector.
    
    Assumes that rpoly is initialised as a sufficiently wide vector.  The 
    input operands are assumed to be in canonical form and are also allowed to 
    be of length 0.
    
    No overlap is allowed between {rpoly, rden} and {poly, den}.

void _fmpq_poly_add(fmpz * rpoly, fmpz_t rden, 
                       const fmpz * poly1, const fmpz_t den1, const ulong len1,
                       const fmpz * poly2, const fmpz_t den2, const ulong len2)

    Forms {rpoly, rden} = {den2 poly1 + den1 poly2, den1 den2}, placing the 
    result into canonical form, that is, the denominator is a positive 
    denominator, which is co-prime to the content of the numerator vector.
    
    Assumes that rpoly is initialised as a sufficiently wide vector.  The 
    input operands are assumed to be in canonical form and are also allowed to 
    be of length 0.
    
    No overlap is allowed between {rpoly, rden} and either of {poly1, den1} 
    and {poly2, den2}.  However, there may be overlap between {poly1, den1} 
    and {poly2, den}.

void fmpq_poly_add_naive(fmpq_poly_t res, fmpq_poly poly1, fmpq_poly poly2)

    Sets res to the sum of poly1 and poly2, using the naive algorithm.

void fmpq_poly_add(fmpq_poly_t res, fmpq_poly poly1, fmpq_poly poly2)

    Sets res to the sum of poly1 and poly2, using Henrici's algorithm.

void fmpq_poly_scalar_mul_si(fmpq_poly_t rop, const fmpq_poly_t op, long c)

void fmpq_poly_scalar_mul_ui(fmpq_poly_t rop, const fmpq_poly_t op, ulong c)

void fmpq_poly_scalar_mul_fmpz(fmpq_poly_t rop, const fmpq_poly_t op, const fmpz_t c)

void fmpq_poly_scalar_mul_mpz(fmpq_poly_t rop, const fmpq_poly_t op, const mpz_t c)

void fmpq_poly_scalar_mul_mpq(fmpq_poly_t rop, const fmpq_poly_t op, const mpq_t c)

void fmpq_poly_scalar_div_si(fmpq_poly_t rop, const fmpq_poly_t op, long c);

void fmpq_poly_scalar_div_ui(fmpq_poly_t rop, const fmpq_poly_t op, ulong c);

void fmpq_poly_scalar_div_fmpz(fmpq_poly_t rop, const fmpq_poly_t op, const fmpz_t c);

void fmpq_poly_scalar_div_mpz(fmpq_poly_t rop, const fmpq_poly_t op, const mpz_t c);

void fmpq_poly_scalar_div_mpq(fmpq_poly_t rop, const fmpq_poly_t op, const mpq_t c);

********************************************************************************

    String conversions

********************************************************************************

ulong _fmpq_poly_decimal_digits(ulong n)

    Ad-hoc auxiliary method, computes the number of decimal digits in n.

char * fmpq_poly_to_string(const fmpq_poly_t poly)

    Returns the string representation of poly.

char * fmpq_poly_to_string_pretty(const fmpq_poly_t poly, const char * var)

    Returns the pretty representation of poly, using the null-terminated 
    string var not equal to "\0" as the variable name.

void fmpq_poly_print(const fmpq_poly_t poly)

    Prints the string representation of poly to stdout.

void fmpq_poly_print_pretty(const fmpq_poly_t poly, const char * var)

    Prints the pretty representation of poly to stdout, using the 
    null-terminated string var not equal to "\0" as the variable name.

