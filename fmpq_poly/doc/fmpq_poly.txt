/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 Sebastian Pancratz
    Copyright (C) 2010 William Hart

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void fmpq_poly_init(fmpq_poly_t poly)

    Initialises the polynomial for use.  The length is set to zero.

void fmpq_poly_init2(fmpq_poly_t poly, long alloc)

    Initialises the polynomial with space for at least alloc coefficients and 
    set the length to zero. The alloc coefficients are all set to zero.

void fmpq_poly_realloc(fmpq_poly_t poly, long alloc)

    Reallocates the given polynomial to have space for alloc coefficients. 
    If alloc is set to zero then the polynomial is cleared and then 
    reinitialised.  If the current length is greater than alloc then poly 
    is first truncated to length alloc.  Note that this might leave the 
    rational polynomial in non-canonical form.

void fmpq_poly_fit_length(fmpq_poly_t poly, long len)

    If len is greater than the number of coefficients currently 
    allocated, then the polynomial is reallocated to have space for at
    least len coefficients. No data is lost when calling this 
    function. The function efficiently deals with the case where 
    fit_length is called many times in small increments by at least 
    doubling the number of allocated coefficients when len is larger 
    than the number of coefficients currently allocated.

void _fmpq_poly_set_length(fmpq_poly_t poly, long len)
    
    Sets the length of the numerator polynomial to len, demoting 
    coefficients beyond the new length.  Note that this method does 
    not guarantee that the rational polynomial is in canonical form.

void fmpq_poly_clear(fmpq_poly_t poly)
    
    Clears the given poly, releasing any memory used. The poly must
    be reinitialised in order to be used again.

void _fmpq_poly_normalise(fmpq_poly_t poly)

    Sets the length of poly so that the top coefficient is nonzero.  If 
    all coefficients are zero, the length is set to zero.  Note that 
    this function does not guarantee the coprimality of the numerator 
    polynomial and the integer denominator.

void _fmpq_poly_canonicalise(fmpz * poly, fmpz_t den, long len)

    Puts {poly, den} of length len into canonical form.
    
    It is assumed that the array poly contains a non-zero entry in position 
    len - 1 whenever len > 0.  Assumes that den is non-zero.

void fmpq_poly_canonicalise(fmpq_poly_t poly)

    Puts the polynomial poly into canonical form.  Firstly, the length is set 
    to the actual length of the numerator polynomial.  For non-zero 
    polynomials, it is then ensured that the numerator and denominator are 
    coprime and that the denominator is positive.  The canonical form of the 
    zero polynomial is a zero numerator polynomial and a one denominator.

*******************************************************************************

    Polynomial parameters

*******************************************************************************

long fmpq_poly_degree(fmpq_poly_t poly)

    Returns the degree of poly, which is one less than its length, as a long. 
    Only gives the right answer for polynomials such that the length, which is 
    an unsigned long, fits into a long.

long fmpq_poly_length(fmpq_poly_t poly)

    Returns the length of poly.

*******************************************************************************

    Accessing the numerator and denominator

********************************************************************************

fmpz * fmpq_poly_numref(fmpq_poly_t poly)

    Returns a reference to the numerator polynomial as a vector.  Note that 
    this might be NULL.
    
    This is implemented as a macro returning (poly)->coeffs.

fmpz_t fmpq_poly_denref(fmpq_poly_t poly)
    
    Returns a reference to the denominator as a fmpz_t.  The integer is 
    guaranteed to be properly initialised.
    
    This is implemented as a macro returning (poly)->den.

********************************************************************************

    Random testing

********************************************************************************

void fmpq_poly_randinit(fmpz_randstate_t state)

    Initialise the random state for random polynomial generation.  One should 
    not call this function if fmpz_randinit has already been called. 

void fmpq_poly_randclear(fmpz_randstate_t state)

    Clear the random state initialised with fmpq_poly_randinit.  One should 
    not call this function if fmpz_randclear has already been called.

void fmpq_poly_randtest(fmpq_poly_t f, fmpz_randstate_t state, 
                                                long len, mp_bitcnt_t bits)

    Sets f to a random polynomial with coefficients up to the given length 
    and where each coefficient has up to the given number of bits.  The 
    coefficients are signed randomly.  One must call fmpq_poly_randinit 
    before calling this function.

void fmpq_poly_randtest_unsigned(fmpq_poly_t f, fmpz_randstate_t state,
                                                long len, mp_bitcnt_t bits)

    Sets f to a random polynomial with coefficients up to the given length 
    and where each coefficient has up to the given number of bits.  One must 
    call fmpq_poly_randinit before calling this function.

void fmpq_poly_randtest_not_zero(fmpq_poly_t f, fmpz_randstate_t state,
                                                long len, mp_bitcnt_t bits)

    As for fmpq_poly_randtest except that length and bits may not be
    zero and the polynomial generated is guaranteed not to be the 
    zero polynomial.  One must call fmpq_poly_randinit before calling
    this function.

*******************************************************************************

    Assignment, swap, negation

********************************************************************************

void fmpq_poly_set(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Sets poly1 to equal poly2.

void fmpq_poly_set_si(fmpq_poly_t poly, long x)

    Sets poly to the integer x.

void fmpq_poly_set_ui(fmpq_poly_t poly, ulong x)

    Sets poly to the integer x.

void fmpq_poly_set_fmpz(fmpq_poly_t poly, const fmpz_t x)

    Sets poly to the integer x.

void fmpq_poly_set_mpz(fmpq_poly_t poly, const mpz_t x)

    Sets poly to the integer x.

void fmpq_poly_set_mpq(fmpq_poly_t poly, const mpq_t x)

    Sets poly to the rational x.

void _fmpq_poly_set_array_mpq(fmpz * poly, fmpz_t den, long n, const mpq_t * a)

    Sets {poly, den} to the polynomial given by the first n coefficients in 
    the array a, from lowest degree to highest degree.

void fmpq_poly_set_array_mpq(fmpq_poly_t poly, const mpq_t * a, long n)

    Sets poly to the polynomial with coefficients as given in the array a, 
    from lowest degree to highest degree.

int _fmpq_poly_set_str(fmpz * poly, fmpz_t den, const char * str)

    Sets {poly, den} to the polynomial specified by the null-terminated 
    string str.
    
    Returns 0 if no error occurred.  Otherwise, returns a non-zero value, in 
    which case the resulting value of {poly, den} is undefined.  If str is not 
    null-terminated, calling this method might result in a segmentation fault.

int fmpq_poly_set_str(fmpq_poly_t poly, const char * str)

    Sets poly to the polynomial specified by the null-terminated string str.
    
    Returns 0 if no error occurred.  Otherwise, returns a non-zero value, in 
    which case the resulting value of poly is undefined.  If str is not 
    null-terminated, calling this method might result in a segmentation fault.

char * fmpq_poly_get_str(const fmpq_poly_t poly)

    Returns the string representation of poly.

char * fmpq_poly_get_str_pretty(const fmpq_poly_t poly, const char * var)

    Returns the pretty representation of poly, using the null-terminated 
    string var not equal to "\0" as the variable name.

void fmpq_poly_zero(fmpq_poly_t poly)

    Sets poly to zero.

void fmpq_poly_neg(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Sets poly1 to the additive inverse of poly2.

void fmpq_poly_inv(fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Sets poly1 to the multiplicative inverse of poly2 if possible.  
    Otherwise, if poly2 is not a unit, leaves poly1 unmodified and 
    calls abort().

void fmpq_poly_swap(fmpq_poly_t poly1, fmpq_poly_t poly2)

    Efficiently swaps the polynomials poly1 and poly2.

*******************************************************************************

    Setting and getting coefficients

********************************************************************************

void fmpq_poly_get_coeff_mpq(mpq_t x, const fmpq_poly_t poly, long n)

    Retrieves the nth coefficient of poly.

void fmpq_poly_set_coeff_si(fmpq_poly_t poly, long n, long x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_ui(fmpq_poly_t poly, long n, ulong x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_fmpz(fmpq_poly_t poly, long n, const fmpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpz(fmpq_poly_t rop, long n, const mpz_t x)

    Sets the nth coefficient in poly to the integer x.

void fmpq_poly_set_coeff_mpq(fmpq_poly_t rop, long n, const mpq_t x)

    Sets the nth coefficient in poly to the rational x.

********************************************************************************

    Comparison

********************************************************************************

int fmpq_poly_equal(const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Return 1 if poly1 is equal to poly2, otherwise return 0.

int _fmpq_poly_cmp(const fmpz * lpoly, const fmpz_t lden, 
                        const fmpz * rpoly, const fmpz_t rden, long len)

    Compares two non-zero polynomials, assuming they have the same length 
    len > 0.

int fmpq_poly_cmp(const fmpq_poly_t left, const fmpq_poly_t right)

    Compares the two polynomials left and right.
    
    Compares the two polynomials left and right, returning -1, 0, or 1 as left 
    is less than, equal to, or greater than right.  The comparison is first 
    done by the degree, and then, in case of a tie, by the individual 
    coefficients from highest to lowest.

int fmpq_poly_is_one(const fmpq_poly_t poly)

    Returns 1 if poly is the constant polynomial 1, otherwise returns 0.

int fmpq_poly_is_zero(const fmpq_poly_t poly)

    Returns 1 if poly is the zero polynomial, otherwise returns 0.

*******************************************************************************

    Addition and subtraction

*******************************************************************************

void _fmpq_poly_add(fmpz * rpoly, fmpz_t rden, 
                    const fmpz * poly1, const fmpz_t den1, long len1,
                    const fmpz * poly2, const fmpz_t den2, long len2)

    Forms {rpoly, rden} = {den2 poly1 + den1 poly2, den1 den2}, placing the 
    result into canonical form, that is, the denominator is a positive 
    integer, which is co-prime to the content of the numerator vector.
    
    Assumes that rpoly is initialised as a sufficiently wide vector.  The 
    input operands are assumed to be in canonical form and are also allowed 
    to be of length 0.
    
    {rpoly, rden} and {poly1, den1} may be aliased, but {rpoly, rden} and 
    {poly2, den2} may not be aliased.

void fmpq_poly_add(fmpq_poly_t res, fmpq_poly poly1, fmpq_poly poly2)

    Sets res to the sum of poly1 and poly2, using Henrici's algorithm.

void _fmpq_poly_sub(fmpz * rpoly, fmpz_t rden, 
                    const fmpz * poly1, const fmpz_t den1, long len1,
                    const fmpz * poly2, const fmpz_t den2, long len2)

    Forms {rpoly, rden} = {den2 poly1 - den1 poly2, den1 den2}, placing the 
    result into canonical form, that is, the denominator is a positive 
    integer, which is co-prime to the content of the numerator vector.
    
    Assumes that rpoly is initialised as a sufficiently wide vector.  The 
    input operands are assumed to be in canonical form and are also allowed to 
    be of length 0.
    
    {rpoly, rden} and {poly1, den1} may be aliased, but {rpoly, rden} and 
    {poly2, den2} may not be aliased.

void fmpq_poly_sub(fmpq_poly_t res, fmpq_poly poly1, fmpq_poly poly2)

    Sets res to the difference of poly1 and poly2, using Henrici's algorithm.

*******************************************************************************

    Scalar multiplication and division

*******************************************************************************

void _fmpq_poly_scalar_mul_si(fmpz * rpoly, fmpz_t rden, 
                        const fmpz * poly, const fmpz_t den, long len, long c)

    Sets {rpoly, rden} = c * {poly, den}, in lowest terms.
    
    Assumes that {poly, den} is provided in lowest terms.  Assumes that rpoly 
    is allocated as a sufficiently large array.  Supports exact aliasing 
    between {rpoly, den} and {poly, den}.

void _fmpq_poly_scalar_mul_ui(fmpz * rpoly, fmpz_t rden, 
                       const fmpz * poly, const fmpz_t den, long len, ulong c)

    Sets {rpoly, rden} = c * {poly, den}, in lowest terms.
    
    Assumes that {poly, den} is provided in lowest terms.  Assumes that rpoly 
    is allocated as a sufficiently large array.  Supports exact aliasing 
    between {rpoly, den} and {poly, den}.

void _fmpq_poly_scalar_mul_fmpz(fmpz * rpoly, fmpz_t rden, 
                const fmpz * poly, const fmpz_t den, long len, const fmpz_t c)

    Sets {rpoly, rden} = c * {poly, den}, in lowest terms.
    
    Assumes that {poly, den} is provided in lowest terms.  Assumes that rpoly 
    is allocated as a sufficiently large array.  Supports exact aliasing 
    between {rpoly, den} and {poly, den}.  The fmpz_t c may not be part of 
    {rpoly, rden}.

void _fmpq_poly_scalar_mul_mpq(fmpz * rpoly, fmpz_t rden, const fmpz * poly, 
               const fmpz_t den, long len, const fmpz_t r, const fmpz_t s)

    Sets {rpoly, rden} = {r, s} * {poly, den}, in lowest terms.
    
    Assumes that {poly, den} and {r, s} is provided in lowest terms.  Assumes 
    that rpoly is allocated as a sufficiently large array.  Supports exact 
    aliasing between {rpoly, den} and {poly, den}, however, there may be no 
    partial overlap between rpoly and poly.  The fmpz_t's r and s may not be 
    part of {rpoly, rden}.

void fmpq_poly_scalar_mul_si(fmpq_poly_t rop, const fmpq_poly_t op, long c)

    Sets rop to c times op.

void fmpq_poly_scalar_mul_ui(fmpq_poly_t rop, const fmpq_poly_t op, ulong c)

    Sets rop to c times op.

void fmpq_poly_scalar_mul_fmpz(fmpq_poly_t rop, 
                                          const fmpq_poly_t op, const fmpz_t c)

    Sets rop to c times op.  Assumes that the fmpz_t c is not part of rop.

void fmpq_poly_scalar_mul_mpz(fmpq_poly_t rop, 
                                           const fmpq_poly_t op, const mpz_t c)

    Sets rop to c times op.

void fmpq_poly_scalar_mul_mpq(fmpq_poly_t rop, 
                                           const fmpq_poly_t op, const mpq_t c)

    Sets rop to c times op.

void _fmpq_poly_scalar_div_fmpz(fmpz * rpoly, fmpz_t rden, const fmpz * poly, 
                                   const fmpz_t den, long len, const fmpz_t c)

    Sets {rpoly, rden, len} to {poly, den, len} divided by c, in lowest terms.
    
    Assumes that len is positive.  Assumes that c is non-zero.  Supports 
    aliasing between {rpoly, rden} and {poly, den}.  Assumes that c is not 
    part of {rpoly, rden}.

void _fmpq_poly_scalar_div_si(fmpz * rpoly, fmpz_t rden, const fmpz * poly, 
                                           const fmpz_t den, long len, long c)

    Sets {rpoly, rden, len} to {poly, den, len} divided by c, in lowest terms.
    
    Assumes that len is positive.  Assumes that c is non-zero.  Supports 
    aliasing between {rpoly, rden} and {poly, den}.

void _fmpq_poly_scalar_div_ui(fmpz * rpoly, fmpz_t rden, const fmpz * poly, 
                                          const fmpz_t den, long len, ulong c)

    Sets {rpoly, rden, len} to {poly, den, len} divided by c, in lowest terms.
    
    Assumes that len is positive.  Assumes that c is non-zero.  Supports 
    aliasing between {rpoly, rden} and {poly, den}.

void _fmpq_poly_scalar_div_mpq(fmpz * rpoly, fmpz_t rden, const fmpz * poly, 
                   const fmpz_t den, long len, const fmpz_t r, const fmpz_t s)

    Sets {rpoly, rden, len} to {poly, den, len} divided by {r, s}, 
    in lowest terms.
    
    Assumes that len is positive.  Assumes that {r, s} is non-zero and in 
    lowest terms.  Supports aliasing between {rpoly, rden} and {poly, den}. 
    The fmpz_t's r and s may not be part of {rpoly, poly}.

void fmpq_poly_scalar_div_si(fmpq_poly_t rop, const fmpq_poly_t op, long c)

void fmpq_poly_scalar_div_ui(fmpq_poly_t rop, const fmpq_poly_t op, ulong c);

void fmpq_poly_scalar_div_fmpz(fmpq_poly_t rop, const fmpq_poly_t op, const fmpz_t c);

void fmpq_poly_scalar_div_mpz(fmpq_poly_t rop, const fmpq_poly_t op, const mpz_t c);

void fmpq_poly_scalar_div_mpq(fmpq_poly_t rop, const fmpq_poly_t op, const mpq_t c);

*******************************************************************************

    Multiplication

*******************************************************************************

void _fmpq_poly_mul(fmpz * rpoly, fmpz_t rden, 
                    const fmpz * poly1, const fmpz_t den1, long len1, 
                    const fmpz * poly2, const fmpz_t den2, long len2)

    Sets {rpoly, rden} to the product of {poly1, den1} and {poly2, den2}.
    Assumes that len1 and len2 are positive and that there is no overlap 
    between {rpoly, rden} and any of the input arguments.  Also assumes that 
    rpoly has space for len1 + len2 - 1 entries.

void fmpq_poly_mul(fmpq_poly_t res, const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Sets res to the product of poly1 and poly2.

*******************************************************************************

    Powering

*******************************************************************************

void _fmpq_poly_pow(fmpz * rpoly, fmpz_t rden, 
                    const fmpz * poly, const fmpz_t den, long len, ulong e)

    Sets {rpoly, rden} to {poly, den}^e, assuming e, len > 0.  Assumes that 
    rpoly is an array of length at least e * (len - 1) + 1.  Supports aliasing 
    of {rpoly, den} and {poly, den}.

void fmpq_poly_pow(fmpq_poly_t res, const fmpq_poly_t poly, ulong e)

    Sets res to pow^e, where the only special case 0^0 is defined as 0.

*******************************************************************************

    Shifting

*******************************************************************************

void fmpz_poly_shift_left(fmpz_poly_t res, const fmpz_poly_t poly, long n)

    Set res to poly shifted left by n coefficients. Zero coefficients are 
    inserted.

void fmpz_poly_shift_right(fmpz_poly_t res, const fmpz_poly_t poly, long n)

    Set res to poly shifted right by n coefficients. If n is equal to or 
    greater than the current length of poly, res is set to the zero polynomial.

*******************************************************************************

    Euclidean division

*******************************************************************************

void _fmpq_poly_divrem(fmpz * Q, fmpz_t q, fmpz * R, fmpz_t r, 
                       const fmpz * A, const fmpz_t a, long lenA,
                       const fmpz * B, const fmpz_t b, long lenB)

    Finds the quotient {Q, q} and remainder {R, r} of the Euclidean 
    division of {A, a} by {B, b}.
    
    Assumes that lenA >= lenB > 0.  Supports no aliasing between the two 
    outputs, or between the inputs and the outputs.

void fmpq_poly_divrem(fmpq_poly_t Q, fmpq_poly_t R, 
                      const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Finds the quotient Q and remainder R of the Euclidean division of poly1 
    by poly2.

*******************************************************************************

    Derivative

*******************************************************************************

void _fmpq_poly_derivative(fmpz * rpoly, fmpz_t rden, 
                           const fmpz * poly, const fmpz_t den, long len)

    Sets {rpoly, rden, len - 1} to the derivative of {poly, den, len}.  Does 
    nothing if len <= 1.  Supports aliasing between the two polynomials.

void fmpq_poly_derivative(fmpq_poly_t res, const fmpq_poly_t poly)

    Sets res to the derivative of poly.

*******************************************************************************

    Evaluation

*******************************************************************************

void _fmpq_poly_evaluate_fmpz(fmpz_t rnum, fmpz_t rden, const fmpz * poly, 
                              const fmpz_t den, long len, const fmpz_t a)

    Evaluates the polynomial {poly, den, len} at the integer a and sets 
    {rnum, rden} to the result in lowest terms.

void fmpq_poly_evaluate_fmpz(mpq_t res, const fmpq_poly_t poly, 
                             const fmpz_t a)

    Evaluates the polynomial poly at the integer a and sets res to the result.

void _fmpq_poly_evaluate_mpq(fmpz_t rnum, fmpz_t rden, 
                             const fmpz * poly, const fmpz_t den, long len, 
                             const fmpz_t anum, const fmpz_t aden)

    Evaluates the polynomial {poly, den, len} at the rational {anum, aden} 
    and sets {rnum, rden} to the result in lowest terms.  
    Aliasing between {rnum, rden} and {anum, aden} is not supported.

void fmpq_poly_evaluate_mpq(mpq_t res, const fmpq_poly_t poly, const mpq_t a)

    Evaluates the polynomial poly at the rational a and sets res to the result.

*******************************************************************************

    Composition

*******************************************************************************

void _fmpq_poly_compose(fmpz * res, fmpz_t den, 
                             const fmpz * poly1, const fmpz_t den1, long len1, 
                             const fmpz * poly2, const fmpz_t den2, long len2)

    Sets {res, den} to the composition of {poly1, den1, len1} and 
    {poly2, den2, len2}, assuming len1, len2 > 0.

    Assumes that res has space for (len1 - 1) * (len2 - 1) + 1 coefficients.
    Does not support aliasing.

void fmpq_poly_compose(fmpq_poly_t res, 
                             const fmpq_poly_t poly1, const fmpq_poly_t poly2)

    Sets res to the composition of poly1 and poly2.

void _fmpq_poly_rescale(fmpz * res, fmpz_t denr, const fmpz * poly, 
              const fmpz_t den, long len, const fmpz_t xnum, const fmpz_t xden)

    Sets {res, denr, len} to {poly, den, len} with the indeterminate 
    rescaled by {xnum, xden}.
    
    Assumes that len > 0 and {xnum, xden} is non-zero and in lowest terms.
    Supports aliasing between {res, denr, len} and {poly, den, len}.

void fmpz_poly_rescale(fmpq_poly_t res, const fmpq_poly_t poly, const mpq_t x)

    Sets res to poly with the interminate rescaled by x.

*******************************************************************************

    Content

*******************************************************************************

void _fmpq_poly_content(mpq_t res, 
                        const fmpz * poly, const fmpz_t den, long len)

    Sets res to the content of {poly, den, len}.  If len == 0, sets res to 
    zero.

void fmpq_poly_content(mpq_t res, const fmpq_poly_t poly)

    Sets res to the content of poly.  The content of the zero polynomial 
    is defined to be zero.

void _fmpq_poly_primitive_part(fmpz * rpoly, fmpz_t rden, 
                               const fmpz * poly, const fmpz_t den, long len)

    Sets {rpoly, rden, len} to the primitive part (with non-negative leading 
    coefficient) of {poly, den, len}.  Assumes that len > 0.  Supports 
    aliasing between the two polynomials.

void fmpq_poly_primitive_part(fmpq_poly_t res, const fmpq_poly_t poly)

    Sets res to the primitive part (with non-negative leading coefficient) 
    of poly.

int _fmpq_poly_is_monic(const fmpz * poly, const fmpz_t den, long len)

    Returns whether the polynomial {poly, den, len} is monic.  The zero 
    polynomial is not monic by definition.

int fmpq_poly_is_monic(const fmpq_poly_t poly)

    Returns whether the polynomial poly is monic.  The zero polynomial is 
    not monic by definition.

void _fmpq_poly_monic(fmpz * rpoly, fmpz_t rden, 
                      const fmpz * poly, const fmpz_t den, long len)

    Sets {rpoly, rden, len} to the monic scalar multiple of {poly, den, len}. 
    Assumes that len > 0.  Supports aliasing between the two polynomials.

void fmpq_poly_monic(fmpq_poly_t res, const fmpq_poly_t poly)

    Sets res to the monic scalar multiple of poly whenever poly is non-zero. 
    If poly is the zero polynomial, sets res to zero.

********************************************************************************

    Square-free

********************************************************************************

int _fmpq_poly_is_squarefree(const fmpz * poly, const fmpz_t den, long len)

    Returns whether the polynomial {poly, den, len} is square-free.

int fmpq_poly_is_squarefree(const fmpq_poly_t poly)

    Returns whether the polynomial poly is square-free.  A non-zero polynomial 
    is defined to be square-free if it has no non-unit square factors.  We 
    also define the zero polynomial to be square-free.
    
    Returns 1 if the length of poly is at most 2.  Returns whether the 
    discriminant is zero for quadratic polynomials.  Otherwise, returns 
    whether the greatest common divisor of poly and its derivative has 
    length 1.

*******************************************************************************

    Printing

*******************************************************************************

void fmpq_poly_print(const fmpq_poly_t poly)

    Prints the string representation of poly to stdout.

void fmpq_poly_print_pretty(const fmpq_poly_t poly, const char * var)

    Prints the pretty representation of poly to stdout, using the 
    null-terminated string var not equal to "\0" as the variable name.

