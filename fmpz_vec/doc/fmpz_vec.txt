/*=============================================================================

    Copyright (C) 2010 William Hart

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/

*******************************************************************************

    Memory management

*******************************************************************************

fmpz * _fmpz_vec_init(ulong len)

    Returns an initialised vector of fmpz's of given length.

void _fmpz_vec_clear(fmpz * vec, ulong len)
 
    Clears the entries of {vec, len} and frees space allocated for vec.

*******************************************************************************

    Randominsation

*******************************************************************************

void _fmpz_vec_randinit(void)

    Initialises the random state for fmpz_vec random functions.

void _fmpz_vec_randclear(void)

    Clears the random state for fmpz_vec random functions.

void _fmpz_vec_randtest(fmpz * f, ulong length, mp_bitcnt_t bits_in)

    Sets the entries of a vector of the given length to random integers with 
    up to the given maximum number of bits per entry.

*******************************************************************************

    Bit sizes

*******************************************************************************

long _fmpz_vec_max_bits(const fmpz * vec, ulong len)

    If b is the maximum number of bits of the absolute value of any 
    coefficient of vec, then if any coefficient of vec is negative, -b is 
    returned, else b is returned.

ulong _fmpz_vec_max_limbs(const fmpz * vec, ulong len)
 
    Return the maximum number of limbs needed to store any entry in 
    {vec, len}.

*******************************************************************************

    Output

*******************************************************************************

void _fmpz_vec_print(fmpz * vec, ulong len)

    Prints the vector of given length to stdout. The format is the length
    followed by two spaces, then a space separated list of coefficients. If
    the length is zero, only 0 is printed.

*******************************************************************************

    Assignment and basic manipulation

*******************************************************************************

void _fmpz_vec_copy(fmpz * vec1, const fmpz * vec2, ulong len2)

    Makes a copy of {vec2, len2} into vec1.

void _fmpz_vec_swap(fmpz * vec1, fmpz * vec2, ulong len2)

    Swaps the integers in {vec1, len2} and {vec2, len2}.

void _fmpz_vec_zero(fmpz * vec, ulong len)

    Zeros the entries of {vec, len}.

void _fmpz_vec_neg(fmpz * vec1, const fmpz * vec2, ulong len2)

    Negates {vec2, len2} and places it into vec1.

*******************************************************************************

    Comparison

*******************************************************************************

int _fmpz_vec_equal(const fmpz * vec1, const fmpz * vec2, const ulong len)

    Compares two vectors of the given length and returns 1 if they are equal, 
    otherwise returns 0.

int _fmpz_vec_is_zero(const fmpz * vec, const ulong len)

    Returns 1 if {vec, len} is zero, and 0 otherwise.

*******************************************************************************

    Addition

*******************************************************************************

void _fmpz_vec_add(fmpz * res, const fmpz * vec1, 
				               const fmpz * vec2, ulong len2)

    Sets {res, len2} = {vec1, len2} + {vec2, len2}.

void _fmpz_vec_sub(fmpz * res, const fmpz * vec1, 
				               const fmpz * vec2, ulong len2)

    Sets {res, len2} = {vec1, len2} - {vec2, len2}.

*******************************************************************************

    Scalar multiplication and division

*******************************************************************************

void _fmpz_vec_scalar_mul_si(fmpz * vec1,
                                      const fmpz * vec2, ulong len2, long c)

    Sets {vec1, len2} to {vec2, len2} * c, where c is a signed long.

void _fmpz_vec_scalar_mul_ui(fmpz * vec1,
                                     const fmpz * vec2, ulong len2, ulong c)

    Sets {vec1, len2} to {vec2, len2} * c, where c is an unsigned long.

void _fmpz_vec_scalar_mul_fmpz(fmpz * vec1, 
                              const fmpz * vec2, ulong len2, const fmpz_t x)

    Sets {vec1, len2} to {vec2, len2} * x, where x is an fmpz.

void _fmpz_vec_scalar_mul_2exp(fmpz * vec1, 
                                   const fmpz * vec2, ulong len2, ulong exp)

    Sets {vec1, len2} to {vec2, len2} * 2^exp.

void _fmpz_vec_scalar_divexact_fmpz(fmpz * vec1, 
                              const fmpz * vec2, ulong len2, const fmpz_t x)

    Sets {vec1, len2} to {vec2, len2} / x, where the division is assumed to 
    be exact for every entry in vec2.

void _fmpz_vec_scalar_divexact_si(fmpz * vec1, 
                                      const fmpz * vec2, ulong len2, long c)

    Sets {vec1, len2} to {vec2, len2} / c, where the divison is assumed to be 
    exact for every entry in vec2.

void _fmpz_vec_scalar_divexact_ui(fmpz * vec1, 
                                     const fmpz * vec2, ulong len2, ulong c)

    Sets {vec1, len2} to {vec2, len2} / c, where the division is assumed to be 
    exact for every entry in vec2.

void _fmpz_vec_scalar_fdiv_q(fmpz * vec1, 
                              const fmpz * vec2, ulong len2, const fmpz_t x)

    Sets {vec1, len2} to {vec2, len2} / x, rounding down towards minus 
    infinity whenever the division is not exact.

void _fmpz_vec_scalar_fdiv_q_2exp(fmpz * vec1, 
                             const fmpz * vec2, ulong len2, const ulong exp)

    Sets {vec1, len2} to {vec2, len2} / 2^exp, rounding down towards minus 
    infinity whenever the division is not exact.

void _fmpz_vec_scalar_addmul_si(fmpz * vec1, 
                                      const fmpz * vec2, ulong len2, long c)

    Sets {vec1, len2} to {vec1, len2} + {vec2, len2} * c, where c is a 
    signed long.

void _fmpz_vec_scalar_addmul_fmpz(fmpz * poly1, 
                             const fmpz * poly2, ulong len2, const fmpz_t x)

    Sets {vec1, len2} to {vec1, len2} + {vec2, len2} * x, where x is an fmpz.

void _fmpz_vec_scalar_addmul_si_2exp(fmpz * vec1, 
                           const fmpz * vec2, ulong len2, long c, ulong exp)

    Sets {vec1, len2} to {vec1, len2} + {vec2, len2} * c * 2^exp, where c is 
    a signed long.

void _fmpz_vec_scalar_submul_si(fmpz * vec1, 
                                      const fmpz * vec2, ulong len2, long c)

    Sets {vec1, len2} to {vec1, len2} - {vec2, len2} * c, where c is a 
    signed long.

void _fmpz_vec_scalar_submul_fmpz(fmpz * vec1, 
                              const fmpz * vec2, ulong len2, const fmpz_t x)

    Sets {vec1, len2} to {vec1, len2} - {vec2, len2} * x, where x is an fmpz.

void _fmpz_vec_scalar_submul_si_2exp(fmpz * vec1, 
                           const fmpz * vec2, ulong len2, long c, ulong exp)

    Sets {vec1, len2} to {vec1, len2} - {vec2, len2} * c * 2^exp, where c is 
    a signed long.

*******************************************************************************

    Gaussian content

*******************************************************************************

void _fmpz_vec_content(fmpz_t res, const fmpz * vec, ulong len)

    Sets res to the non-negative content of the entries in vec.  The content 
    of a length zero vector is defined to be zero.

