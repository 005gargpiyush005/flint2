/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2012 Andres Goens
    Copyright (C) 2012 Sebastian Pancratz

******************************************************************************/

*******************************************************************************

    Module documentation

    We represent a polynomial in $\mathbf{F}_q[X]$ as a \code{struct} 
    which includes an array \code{coeffs} with the coefficients, as
    well as the length \code{length} and the number \code{alloc} of 
    coefficients for which memory has been allocated.

    As a data structure, we call this polynomial \emph{normalised} 
    if the top coefficient is non-zero.

    Unless otherwise stated here, all functions that deal with polynomials 
    assume that the $\mathbf{F}_q$ context of said polynomials are compatible, 
    i.e., it assumes that the fields are generated by the same polynomial.

*******************************************************************************

*******************************************************************************

    Memory management

*******************************************************************************

void fq_poly_init(fq_poly_t poly)

    Initialises \code{poly} for use, with context ctx, and setting 
    its length to zero. A corresponding call to \code{fq_poly_clear()} 
    must be made after finishing with the \code{fq_poly_t} to free the memory 
    used by the polynomial.

void fq_poly_init2(fq_poly_t poly, long alloc)

    Initialises \code{poly} with space for at least \code{alloc} coefficients 
    and sets the length to zero.  The allocated coefficients are all set to 
    zero.

void fq_poly_realloc(fq_poly_t poly, long alloc)

    Reallocates the given polynomial to have space for \code{alloc} 
    coefficients.  If \code{alloc} is zero the polynomial is cleared 
    and then reinitialised.  If the current length is greater than 
    \code{alloc} the polynomial is first truncated to length \code{alloc}.

void fq_poly_fit_length(fq_poly_t poly, long len);

    If \code{len} is greater than the number of coefficients currently 
    allocated, then the polynomial is reallocated to have space for at 
    least \code{len} coefficients.  No data is lost when calling this 
    function.

    The function efficiently deals with the case where \code{fit_length} is 
    called many times in small increments by at least doubling the number 
    of allocated coefficients when length is larger than the number of 
    coefficients currently allocated.

void _fq_poly_set_length(fq_poly_t poly, long newlen)

    Sets the coefficients of \code{poly} beyond \code{len} to zero 
    and sets the length of \code{poly} to \code{len}.

void fq_poly_clear(fq_poly_t poly)

    Clears the given polynomial, releasing any memory used.  It must 
    be reinitialised in order to be used again.

void _fq_poly_normalise(fq_poly_t poly)

    Sets the length of \code{poly} so that the top coefficient is non-zero. 
    If all coefficients are zero, the length is set to zero.  This function 
    is mainly used internally, as all functions guarantee normalisation.

void fq_poly_truncate(fq_poly_t poly, long newlen)

    Truncates the polynomial to length at most~$n$.

*******************************************************************************

    Polynomial parameters

*******************************************************************************

long fq_poly_degree(fq_poly_t poly)

    Returns the degree of the polynomial \code{poly}.

long fq_poly_length(fq_poly_t poly)

    Returns the length of the polynomial \code{poly}.

fq_struct * fq_poly_lead(const fq_poly_t poly)

    Returns a pointer to the leading coefficient of \code{poly}, 
    or \code{NULL} if \code{poly} is the zero polynomial.

*******************************************************************************

    Randomisation

*******************************************************************************

void fq_poly_randtest(fq_poly_t f, flint_rand_t state, 
                      long len, const fq_ctx_t ctx)

    Sets $f$ to a random polynomial of length at most \code{len} 
    with entries in the field described by \code{ctx}.

void fq_poly_randtest_not_zero(fq_poly_t f, flint_rand_t state, 
                               long len, const fq_ctx_t ctx)

    Same as \code{fq_poly_randtest} but guarantees that the polynomial
    is not zero.

*******************************************************************************

    Assignment and basic manipulation

*******************************************************************************

void fq_poly_set(fq_poly_t poly1, const fq_poly_t poly2)

    Sets the polynomial \code{poly1} to the polynomial \code{poly2}.

void fq_poly_set_fq(fq_poly_t poly, const fq_t c)

    Sets the polynomial \code{poly} to \code{c}.

void fq_poly_swap(fq_poly_t op1, fq_poly_t op2)

    Swaps the two polynomials \code{op1} and \code{op2}.

void _fq_poly_zero(fq_struct *rop, long len)

    Sets \code{(rop, len)} to the zero polynomial.

void fq_poly_zero(fq_poly_t poly)

    Sets \code{poly} to the zero polynomial.

void void fq_poly_one(fq_poly_t poly)

    Sets \code{poly} to the constant polynomial~$1$.

*******************************************************************************

    Getting and setting coefficients

*******************************************************************************

void fq_poly_get_coeff(fq_t x, const fq_poly_t poly, long n)

    Sets $x$ to the coefficient of $X^n$ in \code{poly}.

void fq_poly_set_coeff(fq_poly_t poly, long n, const fq_t x)

    Sets the coefficient of $X^n$ in \code{poly} to $x$.

*******************************************************************************

    Comparison

*******************************************************************************

int fq_poly_equal(const fq_poly_t poly1, const fq_poly_t poly2)

    Returns whether the two polynomials \code{poly1} and \code{poly2} 
    are equal.

int fq_poly_is_zero(const fq_poly_t poly)

    Returns whether the polynomial \code{poly} is the zero polynomial.

int fq_poly_is_one(const fq_poly_t op)

    Returns whether the polynomial \code{poly} is equal 
    to the constant polynomial~$1$.

int fq_poly_is_unit(const fq_poly_t op)

    Returns whether the polynomial \code{poly} is a unit in the polynomial
    ring $\mathbf{F}_q[X]$, i.e. if it has degree $0$ and is non-zero.

int fq_poly_equal_fq(const fq_poly_t poly, const fq_t c)

    Returns whether the polynomial \code{poly} is equal the (constant)
    $\mathbf{F}_q$ element \code{c}

*******************************************************************************

    Addition and subtraction

*******************************************************************************

void _fq_poly_add(fq_struct *res, 
                  const fq_struct *poly1, long len1, 
                  const fq_struct *poly2, long len2, 
                  const fq_ctx_t ctx)

void fq_poly_add(fq_poly_t res, const fq_poly_t poly1, const fq_poly_t poly2, 
                 const fq_ctx_t ctx)

    Sets \code{res} to the sum of \code{poly1} and \code{poly2}.

void _fq_poly_sub(fq_struct *res, 
                  const fq_struct *poly1, long len1, 
                  const fq_struct *poly2, long len2, 
                  const fq_ctx_t ctx)

void fq_poly_sub(fq_poly_t res, const fq_poly_t poly1, const fq_poly_t poly2, 
                 const fq_ctx_t ctx)

    Sets \code{res} to the difference of \code{poly1} and \code{poly2}.

void _fq_poly_neg(fq_struct *rop, const fq_struct *op, long len, 
                  const fq_ctx_t ctx)

void fq_poly_neg(fq_poly_t res, const fq_poly_t poly, const fq_ctx_t ctx)

    Sets \code{res} to the additive inverse of \code{poly}.

*******************************************************************************

    Scalar multiplication and division

*******************************************************************************

void _fq_poly_scalar_mul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

void fq_poly_scalar_mul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

void _fq_poly_scalar_addmul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

void fq_poly_scalar_addmul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

void _fq_poly_scalar_submul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

void fq_poly_scalar_submul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

*******************************************************************************

    Multiplication

*******************************************************************************

void _fq_poly_mul_classical(fq_struct *rop, 
                            const fq_struct *op1, long len1, 
                            const fq_struct *op2, long len2, 
                            const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}, assuming that \code{len1} is at least \code{len2} 
    and neither is zero.

    Permits zero padding.  Does not support aliasing of \code{rop} 
    with either \code{op1} or \code{op2}.

void fq_poly_mul_classical(fq_poly_t rop, 
                           const fq_poly_t op1, const fq_poly_t op2, 
                           const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2} 
    using classical polynomial multiplication.

void _fq_poly_mul_reorder(fq_struct *rop, 
                           const fq_struct *op1, long len1, 
                           const fq_struct *op2, long len2, 
                           const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}, assuming that \code{len1} and \code{len2} are 
    non-zero.

    Permits zero padding.  Supports aliasing.

void fq_poly_mul_reorder(fq_poly_t rop, 
    const fq_poly_t op1, const fq_poly_t op2, const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2}, 
    reordering the two indeterminates $X$ and $Y$ when viewing 
    the polynomials as elements of $\mathbf{F}_p[X,Y]$.

    Suppose $\mathbf{F}_q = \mathbf{F}_p[X]/ (f(X))$ and recall 
    that elements of $\mathbf{F}_q$ are internally represented 
    by elements of type \code{fmpz_poly}.  For small degree extensions 
    but polynomials in $\mathbf{F}_q[Y]$ of large degree~$n$, we 
    change the representation to 
    \begin{equation*}
    \begin{split}
    g(Y) & = \sum_{i=0}^{n} a_i(X) Y^i \\
         & = \sum_{j=0}^{d} \sum_{i=0}^{n} \text{Coeff}(a_i(X), j) Y^i.
    \end{split}
    \end{equation*}
    This allows us to use a poor algorithm (such as classical multiplication) 
    in the $X$-direction and leverage the existing fast integer 
    multiplication routines in the $Y$-direction where the polynomial 
    degree~$n$ is large.

void _fq_poly_mul_KS(fq_struct *rop, const fq_struct *op1, long len1, 
                                     const fq_struct *op2, long len2, 
                                     const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}.

    Permits zero padding and places no assumptions on the 
    lengths \code{len1} and \code{len2}.  Supports aliasing.

void fq_poly_mul_KS(fq_poly_t rop, 
                    const fq_poly_t op1, const fq_poly_t op2, 
                    const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2} 
    using Kronecker substitution, that is, by encoding each 
    coefficient in $\mathbf{F}_{q}$ as an integer and reducing 
    this problem to multiplying two polynomials over the integers.

