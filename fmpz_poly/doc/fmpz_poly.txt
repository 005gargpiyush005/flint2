/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2008, 2009 William Hart
    Copyright (C) 2010 Sebastian Pancratz

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void fmpz_poly_init(fmpz_poly_t poly)

    Initialises poly for use.  The length is set to zero.

void fmpz_poly_init2(fmpz_poly_t poly, long alloc)

    Initialises poly with space for at least alloc coefficients and sets 
    the length to zero.  The allocated coefficients are all set to zero.

void fmpz_poly_realloc(fmpz_poly_t poly, long alloc)

    Reallocates the given polynomial to have space for alloc coefficients.
    If alloc is zero then the polynomial is cleared and then reinitialised. 
    If the current length is greater than alloc the poly is first truncated 
    to length alloc.

void fmpz_poly_fit_length(fmpz_poly_t poly, long len)

    If len is greater than the number of coefficients currently allocated, 
    then the polynomial is reallocated to have space for at least len 
    coefficients.  No data is lost when calling this function.
    
    The function efficiently deals with the case where fit_length is called 
    many times in small increments by at least doubling the number of 
    allocated coefficients when length is larger than the number of 
    coefficients currently allocated.

void fmpz_poly_clear(fmpz_poly_t poly)

    Clears the given polynomial, releasing any memory used.  It must 
    be reinitialised in order to be used again.

void _fmpz_poly_normalise(fmpz_poly_t poly)

    Sets the length of poly so that the top coefficient is nonzero. If
    all coefficients are zero, the length is set to zero. This function
    is mainly used internally, as all functions guarantee normalisation.

void _fmpz_poly_set_length(fmpz_poly_t poly, long newlen)

    Demotes the coefficients of poly beyond newlen and sets the length of 
    poly to newlen.

*******************************************************************************

    Polynomial parameters

*******************************************************************************

long fmpz_poly_length(const fmpz_poly_t poly)

    Returns the length of poly.  The zero polynomial has length zero.

long fmpz_poly_degree(const fmpz_poly_t poly)

    Returns the degree of poly, which is one less than its length.

*******************************************************************************

    Assignment and basic manipulation

*******************************************************************************

void fmpz_poly_set(fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets poly1 to equal poly2.

void fmpz_poly_set_ui(fmpz_poly_t poly, ulong c)

    Sets poly to the unsigned integer c.

void fmpz_poly_set_si(fmpz_poly_t poly, long c)

    Sets poly to the signed integer c.

void fmpz_poly_set_fmpz(fmpz_poly_t poly, const fmpz_t c)

    Sets poly to the integer c.

void fmpz_poly_set_mpz(fmpz_poly_t poly, const mpz_t c)

    Sets poly to the integer c.

int _fmpz_poly_set_str(fmpz * poly, const char * str)

    Sets poly to the polynomial encoded in the null-terminated string str.  
    Assumes that poly is allocated as a sufficiently large array suitable for 
    the number of coefficients present in str.
    
    Returns 0 if no error occurred.  Otherwise, returns a non-zero value, in 
    which case the resulting value of poly is undefined.  If str is not 
    null-terminated, calling this method might result in a segmentation fault.

int fmpz_poly_set_str(fmpz_poly_t poly, const char * str)

    Imports a polynomial from a null-terminated string.  If the string str 
    represents a valid polynomial returns 1, otherwise returns 0.
    
    Returns 0 if no error occurred.  Otherwise, returns a non-zero value, in 
    which case the resulting value of poly is undefined.  If str is not 
    null-terminated, calling this method might result in a segmentation fault.

char * _fmpz_poly_get_str(const fmpz * poly, long len)

    Returns the plain FLINT string representation of the polynomial 
    {poly, len}.

char * fmpz_poly_get_str(const fmpz_poly_t poly)

    Returns the plain FLINT string representation of the polynomial poly.

char * _fmpz_poly_get_str_pretty(const fmpz * poly, long len, const char * x)

    Returns a pretty representation of the polynomial {poly, len} using 
    the null-terminated string x as the variable name.

char * fmpz_poly_get_str_pretty(const fmpz_poly_t poly, const char * x)

    Returns a pretty representation of the polynomial poly using the 
    null-terminated string x as the variable name.

void fmpz_poly_zero(fmpz_poly_t poly)

    Sets poly to the zero polynomial.

void fmpz_poly_one(fmpz_poly_t poly)

    Sets poly to the constant polynomial one.

void fmpz_poly_swap(fmpz_poly_t poly1, fmpz_poly_t poly2)

    Swaps poly1 and poly2.  This is done efficiently without copying data
    by swapping pointers, etc.

void _fmpz_poly_reverse(fmpz * res, const fmpz * poly, long len, long n)

    Sets {res, n} to the reverse of {poly, n}, where poly is in fact 
    an array of length len.  Assumes that 0 < len <= n.  Supports aliasing 
    of res and poly, but the behaviour is undefined in case of partial 
    overlap.

void fmpz_poly_reverse(fmpz_poly_t res, const fmpz_poly_t poly, long n)

    This function considers the polynomial poly to be of length n, 
    notionally truncating and zero padding if required, and reverses 
    the result.  Since the function normalises its result res may be 
    of length less than n.

void fmpz_poly_truncate(fmpz_poly_t poly, long newlen)

    If the current length of poly is greater than newlen, it is truncated
    to have the given length.  Discarded coefficients are not necessarily 
    set to zero.


*******************************************************************************

    Randomisation

*******************************************************************************

void fmpz_poly_randinit(fmpz_randstate_t state)

    Initialises the random state for random polynomial generation. 
    One should not call this function if fmpz_randinit has already 
    been called. 

void fmpz_poly_randclear(fmpz_randstate_t state)

    Clears the random state initialised with fmpz_poly_randinit. One 
    should not call this function if fmpz_randclear has already been
    called.

void fmpz_poly_randtest(fmpz_poly_t f, fmpz_randstate_t state, 
                                                long len, mp_bitcnt_t bits)

    Sets f to a random polynomial with up to the given length and where
    each coefficient has up to the given number of bits. The coefficients
    are signed randomly. One must call fmpz_poly_randinit before calling
    this function.

void fmpz_poly_randtest_unsigned(fmpz_poly_t f, fmpz_randstate_t state, 
                                                long len, mp_bitcnt_t bits)

    Sets f to a random polynomial with up to the given length and where
    each coefficient has up to the given number of bits. One must call 
    fmpz_poly_randinit before calling this function.

void fmpz_poly_randtest_not_zero(fmpz_poly_t f, fmpz_randstate_t state, 
                                                long len, mp_bitcnt_t bits)

    As for fmpz_poly_randtest except that len and bits may not be zero and 
    the polynomial generated is guaranteed not to be the zero polynomial. 
    One must call fmpz_poly_randinit before calling this function.

*******************************************************************************

    Getting and setting coefficients

*******************************************************************************

long fmpz_poly_get_coeff_si(const fmpz_poly_t poly, long n)
   
    Returns coefficient n of poly as a long. The result is undefined if the 
    value does not fit into a long. Coefficient numbering is from zero and 
    if n is set to a value beyond the end of the polynomial, zero is 
    returned.

void fmpz_poly_set_coeff_si(fmpz_poly_t poly, long n, long x)

    Sets coefficient n of poly to the long value x. Coefficient numbering
    starts from zero and if n is beyond the current length of poly then
    the polynomial is extended and zero coefficients inserted if 
    necessary.

long fmpz_poly_get_coeff_ui(const fmpz_poly_t poly, long n)
   
    Returns coefficient n of poly as a ulong. The result is undefined if the 
    value does not fit into a ulong. Coefficient numbering is from zero and 
    if n is set to a value beyond the end of the polynomial, zero is 
    returned.

void fmpz_poly_set_coeff_ui(fmpz_poly_t poly, long n, ulong x)

    Sets coefficient n of poly to the ulong value x. Coefficient numbering
    starts from zero and if n is beyond the current length of poly then
    the polynomial is extended and zero coefficients inserted if 
    necessary.

void fmpz_poly_get_coeff_fmpz(fmpz_t x, const fmpz_poly_t poly, long n)

    Gets coefficient n of poly as an fmpz. Coefficient numbering is from zero 
    and if n is set to a value beyond the end of the polynomial, zero is 
    returned.

void fmpz_poly_set_coeff_fmpz(fmpz_poly_t poly, long n, const fmpz_t x)

    Sets coefficient n of poly to the fmpz value x. Coefficient numbering
    starts from zero and if n is beyond the current length of poly then
    the polynomial is extended and zero coefficients inserted if 
    necessary.

*******************************************************************************

    Comparison

*******************************************************************************

int fmpz_poly_equal(const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Returns 1 if poly1 is equal to poly2, otherwise returns 0.  The 
    polynomials are assumed to be normalised.

*******************************************************************************

    Addition and subtraction

*******************************************************************************

void _fmpz_poly_add(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets res to {poly1, len1} + {poly2, len2}. It is assumed that res has 
    sufficient space for the longer of the two polynomials.

void fmpz_poly_add(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Sets res to poly1 + poly2.

void _fmpz_poly_sub(fmpz * res, const fmpz * poly1, long len1, 
                                                const fmpz * poly2, long len2)

    Sets res to {poly1, len1} - {poly2, len2}. It is assumed that res has 
    sufficient space for the longer of the two polynomials.

void fmpz_poly_sub(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Sets res to poly1 - poly2. 

void fmpz_poly_neg(fmpz_poly_t res, const fmpz_poly_t poly)

    Sets res to -poly.

*******************************************************************************

    Scalar multiplication

*******************************************************************************

void fmpz_poly_scalar_mul_ui(fmpz_poly_t poly1, fmpz_poly_t poly2, ulong x)

    Sets poly1 to poly2 times the unsigned long x.

void fmpz_poly_scalar_mul_si(fmpz_poly_t poly1, fmpz_poly_t poly2, long x)

    Sets poly1 to poly2 times the signed long x.

void fmpz_poly_scalar_mul_fmpz(fmpz_poly_t poly1, 
                                       const fmpz_poly_t poly2, const fmpz_t x)

    Sets poly1 to poly2 times the fmpz_t x.

void _fmpz_poly_scalar_addmul_fmpz(fmpz * poly1, 
                                 const fmpz * poly2, long len2, const fmpz_t x)

    Sets poly1 to poly1 + {poly2, len2} times x.

void fmpz_poly_scalar_addmul_fmpz(fmpz_poly_t poly1, const fmpz_poly_t poly2, 
                                                                const fmpz_t x)

    Sets poly to poly1 + poly2 times x.

*******************************************************************************

    Bit packing

*******************************************************************************

void _fmpz_poly_bit_pack(mp_ptr arr, const fmpz * poly,
                                    long len, mp_bitcnt_t bit_size, int negate)   

    Packs the coefficients of poly into bitfields of the given bit_size, 
    negating the coefficients before packing if negate is set to -1.

void _fmpz_poly_bit_unpack(fmpz * poly, long len, 
                               mp_srcptr arr, mp_bitcnt_t bit_size, int negate)

    Unpacks the polynomial of given length from the array as packed into 
    fields of the given bitsize, finally negating the coefficients if negate 
    is set to -1.

void _fmpz_poly_bit_unpack_unsigned(fmpz * poly, long len, 
                                         mp_srcptr_t arr, mp_bitcnt_t bit_size)

    Unpacks the polynomial of given length from the array as packed into 
    fields of the given bitsize. The coefficients are assumed to be unsigned.

*******************************************************************************

    Multiplication

*******************************************************************************

void _fmpz_poly_mul_classical(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets {res, len1 + len2 - 1} to the product of {poly1, len1} and 
    {poly2, len2}.  Assumes len1 and len2 are positive.  Allows zero-padding 
    of the two input polynomials. 
    No aliasing of inputs with outputs is allowed.

void fmpz_poly_mul_classical(fmpz_poly_t res, 
                              const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets res to poly1 multiplied by poly2.

void _fmpz_poly_mullow_classical(fmpz * res, const fmpz * poly1, long len1, 
                                     const fmpz * poly2, long len2, long trunc)

    Sets {res, trunc} to the first trunc coefficients of {poly1, len1} 
    multiplied by {poly2, len2}. Assumes 0 < trunc <= len1 + len2 - 1. Assumes 
    neither len1 nor len2 is zero.

void fmpz_poly_mullow_classical(fmpz_poly_t res, 
                  const fmpz_poly_t poly1, const fmpz_poly_t poly2, long trunc)

    Sets res to the first trunc coefficients of poly1 * poly2.

void _fmpz_poly_mulhigh_classical(fmpz * res, const fmpz * poly1, long len1, 
                                     const fmpz * poly2, long len2, long start)

    Sets the first start coefficients of res to zero and the remainder to the
    corresponding coefficients of {poly1, len1}*{poly2, len2}. Assumes start
    <= len1 + len2 - 1. Assumes neither len1 nor len2 is zero.

void fmpz_poly_mulhigh_classical(fmpz_poly_t res, 
                  const fmpz_poly_t poly1, const fmpz_poly_t poly2, long start)

    Sets the first start coefficients of res to zero and the remainder to the 
    corresponding coefficients of poly1 * poly2.

void _fmpz_poly_mulmid_classical(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets res to the middle len1 - len2 + 1 coefficients of 
    {poly1, len1} * {poly2, len2}, i.e. the coefficient from degree len2 - 1 
    to len1 - 1 inclusive. Assumes neither len1 nor len2 is zero and that 
    len1 >= len2.

void fmpz_poly_mulmid_classical(fmpz_poly_t res, 
                              const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets res to the middle poly1->length - poly2->length + 1 coefficients of 
    poly1 * poly, i.e. the coefficient from degree len2 - 1 to len1 - 1 
    inclusive. Assumes that len1 >= len2.

void _fmpz_poly_mul_karatsuba(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets {res, len1 + len2 - 1} to the product of {poly1, len1} and 
    {poly2, len2}. Assumes len1 >= len2 > 0.  Allows zero-padding of the two 
    input polynomials.
    No aliasing of inputs with outputs is allowed.

void fmpz_poly_mul_karatsuba(fmpz_poly_t res, 
                              const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets res to poly1 multiplied by poly2.

void _fmpz_poly_mullow_karatsuba_n(fmpz * res, const fmpz * poly1, 
                                                 const fmpz * poly2, long len)

    Sets res to poly1 multiplied by poly2 and truncate to the given length. It 
    is assumed that poly1 and poly2 are precisely the given length (possibly 
    zero padded). Assumes len is not zero.

void fmpz_poly_mullow_karatsuba_n(fmpz_poly_t res, 
                    const fmpz_poly_t poly1, const fmpz_poly_t poly2, long len)

    Sets res to poly1 multiplied by poly2 and truncate to the given length. It 
    is assumed that poly1 and poly2 are at most the given length.

void _fmpz_poly_mulhigh_karatsuba_n(fmpz * res, const fmpz * poly1, 
                                                  const fmpz * poly2, long len)

    Sets res to poly1 multiplied by poly2 and truncate at the top to the given 
    length. The first len - 1 coefficients are set to zero. It is assumed that 
    poly1 and poly2 are precisely the given length (possibly zero padded). 
    Assumes len is not zero.

void fmpz_poly_mulhigh_karatsuba_n(fmpz_poly_t res, 
                    const fmpz_poly_t poly1, const fmpz_poly_t poly2, long len)

    Sets the first len - 1 coefficients of the result to zero and the 
    remaining coefficients to the corresponding coefficients of the product of 
    poly1 and poly2. Assumes poly1 and poly2 are at most of the given length.

void _fmpz_poly_mul_KS(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets {res, len1 + len2 - 1} to the product of {poly1, len1} and 
    {poly2, len2}. Places no assumptions on len1 and len2. Allows 
    zero-padding of the two input polynomials. Supports aliasing of 
    inputs and outputs.

void fmpz_poly_mul_KS(fmpz_poly_t res, 
                              const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets res to poly1 multiplied by poly2.

void _fmpz_poly_mullow_KS(fmpz * res, const fmpz * poly1, long len1, 
                                     const fmpz * poly2, long len2, long trunc)

    Sets {res, trunc} to the lowest trunc coefficients of the product of 
    {poly1, len1} and {poly2, len2}.  Assumes that len1 and len2 are 
    positive, but does allow for the polynomials to be zero-padded.  
    The polynomials may be zero, too.  Assumes trunc is positive.  
    Suports aliasing between res, poly1 and poly2.

void fmpz_poly_mullow_KS(fmpz_poly_t res, 
                  const fmpz_poly_t poly1, const fmpz_poly_t poly2, long trunc)

    Sets res to the lowest trunc coefficients of the product of poly1 and 
    poly2.

void _fmpz_poly_mul(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Sets {res, len1 + len2 - 1} to the product of {poly1, len1} and 
    {poly2, len2}.  Assumes len1 >= len2 > 0.  Allows zero-padding of 
    the two input polynomials.

void fmpz_poly_mul(fmpz_poly_t res, 
                              const fmpz_poly_t poly1, const fmpz_poly_t poly2)

    Sets res to poly1 multiplied by poly2. Chooses an optimal algorithm from 
    the choices above.

void _fmpz_poly_mullow_n(fmpz * res, const fmpz * poly1, const fmpz * poly2, 
                                                                      long len)

    Sets {res, len} to the lowest len coefficients of the product of poly1 
    and poly2.  Assumes that poly1 and poly2 are non-zero, and that they are 
    of length precisely len, possibly zero-padded.  Assumes that len > 0.
    Supports no aliasing.

void fmpz_poly_mullow_n(fmpz_poly_t res, 
                  const fmpz_poly_t poly1, const fmpz_poly_t poly2, long trunc)

    Sets res to the low trunc coefficients of poly1 times poly2.

void fmpz_poly_mulhigh_n(fmpz_poly_t res, 
                      const fmpz_poly_t poly1, const fmpz_poly_t poly2, long n)

    Sets the high n coefficients of res to the high n coefficients of the 
    product of poly1 and poly2, assuming the latter are precisely n 
    coefficients in length (zero padded if necessary). The remaining n - 1 
    coefficients may be arbitrary.

*******************************************************************************

    Powering

*******************************************************************************

void _fmpz_poly_pow_multinomial(fmpz * res, 
                                          const fmpz * poly, long len, ulong e)

    Comuputes res = poly^e.  This uses the J.C.P. Miller pure recurrence as 
    follows:
    
    If low is the index of the lowest non-zero coefficient in poly, as a first 
    step this method zeros out the lowest low times e coefficients of res.  
    The recurrence above is then used to compute the remaining coefficients.
    
    Assumes len > 0, e > 0.  Does not support aliasing.

void fmpz_poly_pow_multinomial(fmpz_poly_t res, 
                                               const fmpz_poly_t poly, ulong e)

    Computes res = poly^e using a generalisation of binomial expansion called 
    the J.C.P. Miller pure recurrence.   If poly is zero, returns zero, so 
    that in particular 0^0 = 0.
    
    The formal statement of the recurrence is as follows.  Write the input 
    polynomial as $P(t) = p_0 + p_1 t + \dotsb + p_m t^m$ with $p_0 \neq 0$ 
    and let $P(t)^n = a(n, 0) + a(n, 1) t + \dotsb + a(n, mn) t^{mn}$.  Then 
    $a(n, 0) = p_0^n$ and, for all $1 \leq k \leq mn$, 
    $a(n, k) = (k p_0)^{-1} \sum_{i = 1}^m p_i ((n + 1) i - k) a(n, k-i)$.
    
    [1] D. Knuth, The Art of Computer Programming Vol. 2, Seminumerical 
    Algorithm, Third Edition (Reading, Massachusetts: Addison-Wesley, 1997)
    
    [2] D. Zeilberger, The J.C.P. Miller Recurrence for Exponentiating a 
    Polynomial, and its q-Analog, Journal of Difference Equations and 
    Applications, 1995, Vol. 1, pp. 57--60

void _fmpz_poly_pow_binomial(fmpz * res, const fmpz * poly, ulong e)

    Computes res = poly^e when poly is of length 2, using binomial expansion. 
    Assumes e > 0.  Does not support aliasing.

void fmpz_poly_pow_binomial(fmpz_poly_t res, const fmpz_poly_t poly, ulong e)

    Computes res = poly^e when poly is of length 2, using binomial expansion.
    If the length of poly is not 2, raises an exception and aborts.

void _fmpz_poly_pow_addchains(fmpz * res, const fmpz * poly, long len, 
                                                          const int * a, int n)

    Given a star chain 1 = a[0] < a[1] < ... < a[n] = e computes res = poly^e.
    
    A start chain is an addition chain 1 = a[0] < a[1] < ... < a[n] such that 
    a[i] = a[i-1] + a[j] with j < i for all i > 0.
    
    Assumes that e > 2 (equivalently n > 1) and len > 0.  Does not support 
    aliasing.

void fmpz_poly_pow_addchains(fmpz_poly_t res, const fmpz_poly_t poly, ulong e)
    
    Computes res = poly^e using addition chains whenever 0 <= e <= 148.  
    If e > 148, raises an exception and aborts.

void _fmpz_poly_pow_binexp(fmpz * res, const fmpz * poly, long len, ulong e)

    Sets res = poly^e using left-to-right binary exponentiation, see 
    D. Knuth, ``The Art of Computer Programming Vol. 2'', Seminumerical 
    algorithms, p. 461.
    
    Assumes that len > 0, e > 1.  Assumes that res is an array of length 
    at least e * (len - 1) + 1.  Does not support aliasing.

void fmpz_poly_pow_binexp(fmpz_poly_t res, const fmpz_poly_t poly, ulong e)

    Computes res = poly^e using the binary exponentiation algorithm.  
    If poly is zero, returns zero, so that in particular 0^0 = 0.

void _fmpz_poly_pow_small(fmpz * res, const fmpz * poly, long len, ulong e)

    Sets res = poly^e whenever 0 <= e <= 4.
    
    Assumes that len > 0 and that res is an array of length at least 
    e * (len - 1) + 1.  Does not support aliasing.

void _fmpz_poly_pow(fmpz_poly_t res, const fmpz_poly_t poly, ulong e)

    Sets res = poly^e, assuming that e, len > 0.  Does not support aliasing.

void fmpz_poly_pow(fmpz_poly_t res, const fmpz_poly_t poly, ulong e)

    Computes res = poly^e.  If poly is zero, returns zero, so that in 
    particular 0^0 = 0.

*******************************************************************************

    Shifting

*******************************************************************************

void _fmpz_poly_shift_left(fmpz * res, const fmpz * poly, long len, long n)

    Sets {res, len + n} to {poly, len} shifted left by n coefficients.  
    Inserts zero coefficients at the lower end.  Assumes that len and n are 
    positive, and that res fits len + n elements.  Supports aliasing between 
    res and poly.

void fmpz_poly_shift_left(fmpz_poly_t res, const fmpz_poly_t poly, long n)

    Set res to poly shifted left by n coeffs. Zero coefficients are inserted.

void _fmpz_poly_shift_right(fmpz * res, const fmpz * poly, long len, long n)

    Sets {res, len - n} to {poly, len} shifted right by n coefficients.  
    Assumes that len and n are positive, that len > n, and that res fits 
    len - n elements.  Supports aliasing between res and poly, although in 
    this case the top coefficients of poly are not set to zero.

void fmpz_poly_shift_right(fmpz_poly_t res, const fmpz_poly_t poly, long n)

    Set res to poly shifted right by n coefficients. If n is equal to or 
    greater than the current length of poly, res is set to the zero polynomial.

*******************************************************************************

    Norms

*******************************************************************************

void fmpz_poly_2norm(fmpz_t res, const fmpz_poly_t poly)

    Sets res to the euclidean norm of poly, that is, the integer square root 
    of the sum of the squares of the coefficients of poly.

*******************************************************************************

    Greatest common divisor

*******************************************************************************

void _fmpz_poly_gcd_subresultant(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Computes the greatest common divisor res of {poly1, len1} and 
    {poly2, len2}, assuming len1 >= len2 > 0.  The result is normalised to 
    have positive leading coefficient.  Assumes that res has space for 
    len2 coefficients.  Aliasing between res, poly1 and poly2 is supported.

void fmpz_poly_gcd_subresultant(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Computes the greatest common divisor res of poly1 and poly2, normalised 
    to have non-negative leading coefficient.

void _fmpz_poly_gcd(fmpz * res, const fmpz * poly1, long len1, 
                                                 const fmpz * poly2, long len2)

    Computes the greatest common divisor res of {poly1, len1} and 
    {poly2, len2}, assuming len1 >= len2 > 0.  The result is normalised to 
    have positive leading coefficient.  Assumes that res has space for 
    len2 coefficients.  Aliasing between res, poly1 and poly2 might not be 
    supported.

void fmpz_poly_gcd(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Computes the greatest common divisor res of poly1 and poly2, normalised 
    to have non-negative leading coefficient.

*******************************************************************************

    Gaussian content

*******************************************************************************

void _fmpz_poly_content(fmpz_t res, const fmpz * poly, long len)

    Sets res to the non-negative content of {poly, len}.  Aliasing between 
    res and the coefficients of poly is not supported.

void fmpz_poly_content(fmpz_t res, const fmpz_poly_t poly)

    Sets res to the non-negative content of poly.  The content of the zero 
    polynomial is defined to be zero.  Supports aliasing, that is, res is 
    allowed to be one of the coefficients of poly.

void _fmpz_poly_primitive_part(fmpz * res, const fmpz * poly, long len)

    Sets {res, len} to {poly, len} divided by the content of {poly, len}, 
    and normalises the result to have non-negative leading coefficient. 
    Assumes that {poly, len} is non-zero.  Supports aliasing of res and poly.

void fmpz_poly_primitive_part(fmpz_poly_t res, const fmpz_poly_t poly)

    Sets res to poly divided by the content of poly, and normalises the result 
    to have non-negative leading coefficient.  If poly is zero, sets res to 
    zero.

*******************************************************************************

    Euclidean division

*******************************************************************************

void _fmpz_poly_divrem_basecase(fmpz * Q, fmpz * R, const fmpz * A, 
                                          long lenA, const fmpz * B, long lenB)

    Computes Q, R such that A = B*Q + R and each coefficient of R beyond 
    B->length - 1 is reduced mod the leading coefficient of B. If the leading 
    coefficient of B is +/-1 or the division is exact, this is the same thing 
    as division over Q.

    Assumes that lenB > 0.  Allows zero-padding in {A, lenA}.  R and A may be 
    aliased, but apart from this no aliasing of input and output operands is 
    allowed.

void fmpz_poly_divrem_basecase(fmpz_poly_t Q, fmpz_poly_t R, 
                                      const fmpz_poly_t A, const fmpz_poly_t B)

    Computes Q, R such that A = B*Q + R and each coefficient of R beyond 
    B->length - 1 is reduced mod the leading coefficient of B. If the leading 
    coefficient of B is +/-1 or the division is exact, this is the same thing 
    as division over Q. An exception is raised if B is zero.

void _fmpz_poly_divrem_divconquer_recursive(fmpz * Q, fmpz * BQ, 
                                    const fmpz * A, const fmpz * B, long B_len)

    Computes Q, BQ such that BQ = B*Q and A = BQ + R for some R where each 
    coefficient of R beyond B->length - 1 is reduced mod the leading 
    coefficient of B. We assume that A->length = 2*B->length - 1. If the 
    leading coefficient of B is +/-1 or the division is exact, this is the 
    same thing as division over Q. No aliasing of input and output operands 
    is allowed. An exception is raised if B_len == 0.

void _fmpz_poly_divrem_divconquer(fmpz * Q, fmpz * R, 
                        const fmpz * A, long A_len, const fmpz * B, long B_len)

    Computes Q, R such that A = B*Q + R and each coefficient of R beyond 
    B->length - 1 is reduced mod the leading coefficient of B. If the leading 
    coefficient of B is +/-1 or the division is exact, this is the same thing 
    as division over Q. No aliasing of input and output operands is allowed. 
    An exception is raised if B_len == 0.

void fmpz_poly_divrem_divconquer(fmpz_poly_t Q, fmpz_poly_t R, 
                                      const fmpz_poly_t A, const fmpz_poly_t B)

    Computes Q, R such that A = B*Q + R and each coefficient of R beyond 
    B->length - 1 is reduced mod the leading coefficient of B. If the leading 
    coefficient of B is +/-1 or the division is exact, this is the same thing 
    as division over Q. An exception is raised if B->length == 0.

void _fmpz_poly_div_basecase(fmpz * Q, fmpz * T, const fmpz * A, long lenA,
                                                     const fmpz * B, long lenB)

    Computes the quotient {Q, lenA - lenB + 1} of {A, lenA} divided by 
    {B, lenB}.

    Notationally, computes Q, R such that A = B*Q + R and each coefficient 
    of R beyond B->length - 1 is reduced mod the leading coefficient of B. 
    If the leading coefficient of B is +/-1 or the division is exact, this 
    is the same thing as division over Q.

    Assumes lenB > 0.  Allows zero-padding in {A, lenA}.  Requires a 
    temporary array T of size at least the (actual) length of A.  For 
    convenience, T may be NULL.  T and A may be aliased, but apart from this 
    no aliasing of input and output operands is allowed.

void fmpz_poly_div_basecase(fmpz_poly_t Q, 
                                      const fmpz_poly_t A, const fmpz_poly_t B)

    Computes the quotient Q of A divided by Q.

    Notationally, computes Q, R such that A = B*Q + R and each coefficient 
    of R beyond B->length - 1 is reduced mod the leading coefficient of B. 
    If the leading coefficient of B is +/-1 or the division is exact, this 
    is the same thing as division over Q. An exception is raised if B is zero.

void _fmpz_poly_divremlow_divconquer_recursive(fmpz * Q, fmpz * QB, 
                                    const fmpz * A, const fmpz * B, long lenB)

    Divide and conquer division of {A, 2 lenB - 1} by {B, lenB}, computing 
    only the bottom lenB - 1 coefficients of Q*B.

    Assumes lenB > 0.  Requires QB to have length at least 2 lenB - 1, 
    although only the bottom lenB - 1 will carry meaningful output.  Does 
    not support any aliasing.  Allows zero-padding in A, but not in B.

void _fmpz_poly_div_divconquer_recursive(fmpz * Q, fmpz * temp, 
                                    const fmpz * A, const fmpz * B, long lenB)

    Recursive short division in the balanced case.

    Computes the quotient {Q, lenB} of {A, 2 lenB - 1} upon division 
    by {B, lenB}.  Requires lenB > 0.  Needs a temporary array temp 
    of length 2 lenB - 1.  Does not support any aliasing.

    See Thom Mulders, On Short Multiplications and Divisions.

void _fmpz_poly_div_divconquer(fmpz * Q, const fmpz * A, long lenA, 
                                         const fmpz * B, long lenB)

    Computes the quotient {Q, lenA - lenB + 1} of {A, lenA} divided by 
    {B, lenB}.  Assumes that lenA >= lenB > 0.  Does not support 
    aliasing.

fmpz_poly_div_divconquer(fmpz_poly_t Q, 
                         const fmpz_poly_t A, const fmpz_poly_t B)

    Computes the quotient of A divided by B.  Assumes that B is non-zero.

void _fmpz_poly_rem_basecase(fmpz * R, const fmpz * A, long lenA, 
                                       const fmpz * B, long lenB)

    Computes the remainder {R, lenA} of {A, lenA} upon division by {B, lenB}.

    Notationally, computes Q, R such that A = B*Q + R and each coefficient 
    of R beyond lenB - 1 is reduced mod the leading coefficient of B. If the 
    leading coefficient of B is +/-1 or the division is exact, this is the 
    same thing as division over Q.

    Assumes that lenB > 0.  Allows zero-padding in {A, lenA}.  R and A may be 
    aliased, but apart from this no aliasing of input and output operands is 
    allowed.

void fmpz_poly_rem_basecase(fmpz_poly_t R, 
                                      const fmpz_poly_t A, const fmpz_poly_t B)

    Computes the remaeinder R of A upon division by B.

    Notationally, computes Q, R such that A = B*Q + R and each coefficient 
    of R beyond B->length - 1 is reduced mod the leading coefficient of B. If 
    the leading coefficient of B is +/-1 or the division is exact, this is the 
    same thing as division over Q. An exception is raised if B is zero.

void _fmpz_poly_newton_inv(fmpz * Qinv, fmpz * temp, const fmpz * Q, long n)

    Computes the first n terms of the inverse power series of Q using 
    Newton iteration.

    Assumes that n >= 1, that Q has length at least n and constant term 1.
    Requires an array temp of length at least max(2 * n, 3 * 32).
    Does not support aliasing between the three arrays Qinv, temp, and Q.

void fmpz_poly_newton_inv(fmpz_poly_t Qinv, const fmpz_poly_t Q, long n)

    Computes the first n terms of the inverse power series of Q using 
    Newton iteration, assuming that Q has constant term 1.

*******************************************************************************

    Pseudo division

*******************************************************************************

void _fmpz_poly_pseudo_divrem_basecase(fmpz * Q, fmpz * R, ulong * d, 
                          const fmpz * A, long lenA, const fmpz * B, long lenB)

    If L is the leading coefficient of B, then computes Q, R such that 
    L^d*A = QB + R. This function is used for simulating division over QQ. 
    Assumes that lenA >= lenB > 0.
    Assumes that Q can fit lenA - lenB + 1 coefficients, and that R can 
    fit lenA coefficients.
    Supports aliasing of {R, lenA} and {A, lenA}.  But other than this, 
    no aliasing of the inputs and outputs is suppported.

void fmpz_poly_pseudo_divrem_basecase(fmpz_poly_t Q, fmpz_poly_t R, 
                           ulong * d, const fmpz_poly_t A, const fmpz_poly_t B)

    If L is the leading coefficient of B, then computes Q, R such that 
    L^d*A = QB + R. This function is used for simulating division over QQ. 

void _fmpz_poly_pseudo_divrem_cohen(fmpz * Q, fmpz * R, const fmpz * A, 
                                          long lenA, const fmpz * B, long lenB)

    Assumes that lenA >= lenB > 0.
    Assumes that Q can fit lenA - lenB + 1 coefficients, and that R can 
    fit lenA coefficients.
    Supports aliasing of {R, lenA} and {A, lenA}.  But other than this, 
    no aliasing of the inputs and outputs is supported.

void fmpz_poly_pseudo_divrem_cohen(fmpz_poly_t Q, fmpz_poly_t R, 
                                      const fmpz_poly_t A, const fmpz_poly_t B)

    This is a variant of fmpz_poly_pseudo_divrem which computes polynomials 
    Q and R such that lead(B)^d * A = B * Q + R.  However, the value of d 
    is fixed at the maximum of 0 and A->length - B->length + 1.
    
    This function is faster when the remainder is not well behaved, i.e. 
    where it is not expected to be close to zero.  Note that this function 
    is not asymptotically fast.  It is efficient only for short polynomials, 
    e.g. when B->length < 32.

void _fmpz_poly_pseudo_rem_cohen(fmpz * R, const fmpz * A, long lenA, 
                                                     const fmpz * B, long lenB)

    Assumes that lenA >= lenB > 0.  Assumes that R can fit lenA coefficients. 
    Supports aliasing of {R, lenA} and {A, lenA}.  But other than this, no 
    aliasing of the inputs and outputs is supported.

void fmpz_poly_pseudo_rem_cohen(fmpz_poly_t R, const fmpz_poly_t A, 
                                                           const fmpz_poly_t B)

    This is a variant of fmpz_poly_pseudo_rem which computes polynomials 
    Q and R such that lead(B)^d * A = B * Q + R, but only returns R.  However, 
    the value of d is fixed at the maximum of 0 and A->length - B->length + 1.
    
    This function is faster when the remainder is not well behaved, i.e. 
    where it is not expected to be close to zero.  Note that this function 
    is not asymptotically fast.  It is efficient only for short polynomials, 
    e.g. when B->length < 32.

*******************************************************************************

    Derivative

*******************************************************************************

void _fmpz_poly_derivative(fmpz * rpoly, const fmpz * poly, long len) 

    Sets {rpoly, len - 1} to the derivative of {poly, len}.  Also handles the 
    cases len == 0 and len == 1 correctly.  Supports aliasing of rpoly and 
    poly.

void fmpz_poly_derivative(fmpz_poly_t res, const fmpz_poly_t poly)

    Sets res to the derivative of poly.

*******************************************************************************

    Evaluation

*******************************************************************************

void _fmpz_poly_evaluate_horner(fmpz_t res, const fmpz * f, long len, 
                                const fmpz_t a)

    Evaluates the polynomial {f, len} at the integer a using Horner's rule, 
    and sets res to the result.  Aliasing between res and a or any of the 
    coefficients of f is not supported.

void fmpz_poly_evaluate_horner(fmpz_t res, const fmpz_poly_t f, const fmpz_t a)

    Evaluates the polynomial f at the integer a using Horner's rule, and 
    sets res to the result.

    As expected, aliasing between res and a is supported.  However, res may 
    not be aliased with a coefficient of f.

void _fmpz_poly_evaluate(fmpz_t res, const fmpz * f, long len, const fmpz_t a)

    Evaluates the polynomial {f, len} at the integer a and sets res to the 
    result.  Aliasing between res and a or any of the coefficients of f is 
    not supported.

void fmpz_poly_evaluate(fmpz_t res, const fmpz_poly_t f, const fmpz_t a)

    Evaluates the polynomial f at the integer a and sets res to the result.

    As expected, aliasing between res and a is supported.  However, res may 
    not be aliased with a coefficient of f.

void _fmpz_poly_evaluate_horner_(fmpz_t rnum, fmpz_t rden, 
                                 const fmpz * f, long len, 
                                 const fmpz_t anum, const fmpz_t aden)

    Evaluates the polynomial {f, len} at the rational {anum, aden} using 
    Horner's rule, and sets {rnum, rden} to the result in lowest terms.  
    Aliasing between {rnum, rden} and {anum, aden} or any of the coefficients 
    of f is not supported.

void fmpz_poly_evaluate_horner_mpq(mpq_t res, const fmpz_poly_t f, 
                                                                 const mpq_t a)

    Evaluates the polynomial f at the rational a using Horner's rule, and 
    sets res to the result.

void _fmpz_poly_evaluate_mpq(fmpz_t rnum, fmpz_t rden, 
                             const fmpz * f, long len, 
                             const fmpz_t anum, const fmpz_t aden)

    Evaluates the polynomial {f, len} at the rational {anum, aden} and sets 
    {rnum, rden} to the result in lowest terms.  Aliasing between {rnum, rden} 
    and {anum, aden} or any of the coefficients of f is not supported.

void fmpz_poly_evaluate_mpq(mpq_t res, const fmpz_poly_t f, const mpq_t a)

    Evaluates the polynomial f at the rational a and sets res to the result.

*******************************************************************************

    Composition

*******************************************************************************

void _fmpz_poly_compose_horner(fmpz * res, 
                  const fmpz * poly1, long len1, const fmpz * poly2, long len2)

    Sets res to the composition of {poly1, len1} and {poly2, len2}.  
    Assumes that res has space for (len1-1)*(len2-1) + 1 coefficients.
    Assumes that poly1 and poly2 are non-zero polynomials.
    Does not support aliasing between any of the inputs and the output.

void fmpz_poly_compose_horner(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Sets res to the composition of poly1 and poly2.  To be more precise, 
    denoting res, poly1, and poly2 by f, g, and h, sets f(t) = g(h(t)).  
    
    This implementation uses Horner's method.

void _fmpz_poly_compose_divconquer(fmpz * res, const fmpz * poly1, long len1, 
                                               const fmpz * poly2, long len2)

   Computes the composition of {poly1, len1} and {poly2, len2} using 
   a divide and conquer approach and places the result into res, assuming 
   res can hold the output of length (len1 - 1) * (len2 - 1) + 1.
   
   Assumes len1, len2 > 0.
   Does not support aliasing between res and any of {poly1, len1} and 
   {poly2, len2}.

void fmpz_poly_compose_divconquer(fmpz_poly_t res, const fmpz_poly_t poly1,
                                                   const fmpz_poly_t poly2)

    Sets res to the composition of poly1 and poly2.  To be precise about the 
    order of composition, denoting res, poly1, and poly2 by f, g, and h, 
    respectively, sets f(t) = g(h(t)).

void _fmpz_poly_compose(fmpz * res, 
                  const fmpz * poly1, long len1, const fmpz * poly2, long len2)

    Sets res to the composition of {poly1, len1} and {poly2, len2}.  
    Assumes that res has space for (len1-1)*(len2-1) + 1 coefficients.
    Assumes that poly1 and poly2 are non-zero polynomials.
    Does not support aliasing between any of the inputs and the output.

void fmpz_poly_compose(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                                       const fmpz_poly_t poly2)

    Sets res to the composition of poly1 and poly2.  To be precise about the 
    order of composition, denoting res, poly1, and poly2 by f, g, and h, 
    respectively, sets f(t) = g(h(t)).

*******************************************************************************

    Signature

*******************************************************************************

void _fmpz_poly_signature(long * r1, long * r2, fmpz * poly, long len)

    Computes the signature (r1, r2) of the polynomial {poly, len}.
    Assumes that the polynomial is squarefree over Q.

void fmpz_poly_signature(long * r1, long * r2, fmpz_poly_t poly)

    Computes the signature (r1, r2) of the polynomial poly, which is 
    assumed to be square-free over Q.  The values of r1 and 2*r2 are the 
    number of real and complex roots of the polynomial, respectively. 
    For convenience, the zero polynomial is allowed, in which case 
    the output is (0, 0).
    
    If the polynomial is not square-free, the behaviour is undefined and an 
    exception may be raised.
    
    See H. Cohen, A Course in Computational Number Theory, Algorithm 4.1.11.

*******************************************************************************

    Printing

*******************************************************************************

void fmpz_poly_print(const fmpz_poly_t poly)

    Prints the polynomial to stdout. First the length of the polynomial is
    printed. If the length is not zero two spaces are printed after the 
    length, then a space separated list of coefficients is printed, starting
    with the constant coefficient.

