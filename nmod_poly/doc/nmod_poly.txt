/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 William Hart

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void nmod_poly_init(nmod_poly_t poly, mp_limb_t n)

    Initialises \code{poly}. It will have coefficients modulo~$n$.

void nmod_poly_init_preinv(nmod_poly_t poly, mp_limb_t n, mp_limb_t ninv)

    Initialises \code{poly}. It will have coefficients modulo~$n$.  
    The caller supplies a precomputed inverse limb generated by 
    \code{n_preinvert_limb()}.

void nmod_poly_init2(nmod_poly_t poly, mp_limb_t n, long alloc)

    Initialises \code{poly}. It will have coefficients modulo~$n$.
    Up to \code{alloc} coefficients may be stored in \code{poly}.

void nmod_poly_init2_preinv(nmod_poly_t poly, 
                       mp_limb_t n, mp_limb_t ninv, long alloc)

    Initialises \code{poly}. It will have coefficients modulo~$n$. 
    The caller supplies a precomputed inverse limb generated by 
    \code{n_preinvert_limb()}. Up to \code{alloc} coefficients may 
    be stored in \code{poly}.

void nmod_poly_realloc(nmod_poly_t poly, long alloc)

    Reallocates \code{poly} to the given length. If the current 
    length is less than \code{alloc}, the polynomial is truncated 
    and normalised.  If \code{alloc} is zero, the polynomial is 
    cleared.

void nmod_poly_clear(nmod_poly_t poly)

    Clears the polynomial and releases any memory it used. The polynomial 
    cannot be used again until it is initialised.

void nmod_poly_fit_length(nmod_poly_t poly, long alloc)

    Ensures \code{poly} has space for at least \code{alloc} coefficients. 
    This function only ever grows the allocated space, so no data loss can 
    occur.

*******************************************************************************

    Basic manipulation

*******************************************************************************

void _nmod_poly_normalise(nmod_poly_t poly)

    Internal function for normalising a polynomial so that the final 
    coefficient (if there are any at all) is not zero.

void nmod_poly_swap(nmod_poly_t poly1, nmod_poly_t poly2)

    Efficiently swaps \code{poly1} and \code{poly2} by swapping pointers 
    internally. 

mp_bitcnt_t nmod_poly_max_bits(nmod_poly_t poly)

    Returns the maximum number of bits of any coefficient of \code{poly}.

void nmod_poly_truncate(nmod_poly_t poly, long len)

    Truncates \code{poly} to the given length and normalises it. 
    If \code{len} is bigger than the current length of \code{poly}, 
    then nothing happens.

*******************************************************************************

    Polynomial properties

*******************************************************************************

long nmod_poly_length(nmod_poly_t poly)

   Return the length of the polynomial \code{poly}. The zero polynomial
   has length zsro.

long nmod_poly_degree(nmod_poly_t poly)

   Return the degree of the polynomial \code{poly}. The zero polynomial
   is deemed to have degree \code{-1}.

mp_limb_t nmod_poly_modulus(nmod_poly_t poly)

   Return the modulus of the polynomial \code{poly}. This will be a 
   positive integer.

int nmod_poly_is_zero(nmod_poly_t poly)

   Return one if the polynomial \code{poly} is the zero polynomial,
   otherwise return zero.

*******************************************************************************

    Getting/setting coefficients

*******************************************************************************

ulong nmod_poly_get_coeff_ui(nmod_poly_t poly, ulong j)

   Get the coefficient of \code{poly} at index \code{j} (coefficients 
   being numbered with zero being the constant coefficient) and return
   it as a \code{ulong}. If \code{j} refers to a coefficient beyond the
   end of \code{poly}, zero is returned.

void nmod_poly_set_coeff_ui(nmod_poly_t poly, ulong j, ulong c)

   Set the coefficient of \code{poly} at index \code{j} (coefficients 
   being numbered with zero being the constant coefficient) to the value
   \code{c} reduced modulo the modulus of \code{poly}. If \code{j} 
   refers to a coefficient beyond the current end of \code{poly}, the
   polynomial is first resized, with intervening coefficients being
   set to zero.

*******************************************************************************

    Random generation

*******************************************************************************

void nmod_poly_randtest(nmod_poly_t poly, long len)

    Generates a random polynomial with up to the given length.

*******************************************************************************

    Comparison

*******************************************************************************

int nmod_poly_equal(nmod_poly_t a, nmod_poly_t b)

    Returns $1$ if the polynomials are equal, otherwise $0$.

*******************************************************************************

    Input and output

*******************************************************************************

void nmod_poly_print(nmod_poly_t a)

    Prints the polynomial to \code{stdout}. The length is printed, 
    followed by a space, then the modulus. If the length is zero this is
    all thar is printed, otherwise two spaces followed by a space 
    separated list of coefficients is printed, beginning with the constant 
    coefficient.

char * nmod_poly_to_string(nmod_poly_t poly)

    Writes \code{poly} to a string representation. The format is as 
    described for \code{nmod_poly_print}. The string must be freed by the 
    user when finished. For this it is sufficient to call \code{free}.

int nmod_poly_from_string(nmod_poly_t poly, char * s)

    Read \code{poly} from a string \code{s}. The format is as described
    for \code{nmod_poly_print}. If a polynomial in the correct format
    is read, a positive value is returned, otherwise a non-positive value 
    is returned.

int nmod_poly_fread(FILE * f, nmod_poly_t poly)

   Read \code{poly} from the file stream \code{f}. If this is a file
   that has just been written, the file should be closed then opened
   again. The format is as described for \code{nmod_poly_print}. If a 
   polynomial in the correct format is read, a positive value is returned, 
   otherwise a non-positive value is returned.

void nmod_poly_fprint(FILE * f, nmod_poly_t poly)

   Write a polynomial to the file stream \code{f}. If this is a file
   then the file should be closed and reopened before being read.
   The format is as described for \code{nmod_poly_print}. If a 
   polynomial in the correct format is read, a positive value is returned, 
   otherwise a non-positive value is returned. If an error occurs 
   whilst writing to the file, an error message is printed.

int nmod_poly_read(nmod_poly_t poly)

   Read \code{poly} from \code{stdin}. The format is as described for 
   \code{nmod_poly_print}. If a polynomial in the correct format is read, a 
   positive value is returned, otherwise a non-positive value is returned.

*******************************************************************************

    Reversal

*******************************************************************************

void _nmod_poly_reverse(mp_ptr output, mp_srcptr input, long len, long m)

   Set \code{output} to the reverse of \code{input}, which is of length
   \code{len}, but thinking of it as a polynomial of length \code{m} 
   (notionally zero padded if necessary). The length \code{m} must be 
   non-negative, but there are no other restrictions. The polynomial
   \code{output} must have space for \code{m} coefficients. 

void nmod_poly_reverse(nmod_poly_t output, nmod_poly_t input, long m)

   Set \code{output} to the reverse of \code{input}, thinking of it as
   a polynomial of length \code{m} (notionally zero padded if necessary).
   The length \code{m} must be non-negative, but there are no other
   restrictions. The output polynomial will be set to length \code{m}
   and then normalised.

*******************************************************************************

    Bit packing and unpacking

*******************************************************************************

void _nmod_poly_bit_pack(mp_ptr res, mp_srcptr poly, long len, 
                                                     mp_bitcnt_t bits)

    Packs \code{len} coefficients of \code{poly} into fields of the given 
    number of bits in the large integer \code{res}, i.e.\ evaluates 
    \code{poly} at \code{2^bits} and store the result in \code{res}. 
    Assumes \code{len > 0} and \code{bits > 0}. Also assumes that no 
    coefficient of \code{poly} is bigger than \code{bits/2} bits. We 
    also assume \code{bits < 3 * FLINT_BITS}.

void _nmod_poly_bit_unpack(mp_ptr res, mp_srcptr mpn, 
                                          long len, ulong bits, nmod_t mod)

    Unpacks \code{len} coefficients stored in the big integer \code{mpn} 
    in bit fields of the given number of bits, reduces them modulo the 
    given modulus, then stores them in the polynomial \code{res}. 
    We assume \code{len > 0} and \code{3 * FLINT_BITS > bits > 0}.
    There are no restrictions on the size of the actual coefficients as 
    stored within the bitfields. 

*******************************************************************************

    Basic arithmetic

*******************************************************************************

void nmod_poly_zero(nmod_poly_t res)

    Sets \code{res} to the zero polynomial.

void nmod_poly_neg(nmod_poly_t res, const nmod_poly_t poly1)

    Sets \code{res} to the negation of \code{poly1}.

*******************************************************************************

    Addition/subtraction

*******************************************************************************

void _nmod_poly_add(mp_ptr res, mp_srcptr poly1, long len1, 
                         mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{res} to the sum of \code{(poly1, len1)} and 
    \code{(poly2, len2)}. There are no restrictions on the lengths.

void nmod_poly_add(nmod_poly_t res, const nmod_poly_t poly1, 
                                            const nmod_poly_t poly2)

    Sets \code{res} to the sum of \code{poly1} and \code{poly2}.

void _nmod_poly_sub(mp_ptr res, mp_srcptr poly1, long len1, 
                         mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{res} to the difference of \code{(poly1, len1)} and 
    \code{(poly2, len2)}. There are no restrictions on the lengths.

void nmod_poly_sub(nmod_poly_t res, const nmod_poly_t poly1, 
                                    const nmod_poly_t poly2)

    Sets \code{res} to the difference of \code{poly1} and \code{poly2}.

*******************************************************************************

    Scalar multiplication

*******************************************************************************

void nmod_poly_scalar_mul(nmod_poly_t res, 
                          const nmod_poly_t poly1, mp_limb_t c)

    Sets \code{res} to \code{(poly1, len1)} multiplied by $c$, 
    where $c$ is reduced modulo the modulus of \code{poly1}.

void nmod_poly_make_monic(nmod_poly_t output, nmod_poly_t input)

   Set \code{output} to be the scalar multiple of \code{input} with leading
   coefficient one (if such a polynomial exists). If \code{input} is zero
   an exception is raised. If the leading coefficient of \code{input} is not
   invertible, \code{output} is set to the multiple of \code{input} whose
   leading coefficient is the greatest common divisor of the leading 
   coefficient and the modulus of \code{input}.

*******************************************************************************

    Shifting

*******************************************************************************

void nmod_poly_shift_left(nmod_poly_t res, nmod_poly_t poly, long k)

   Set \code{res} to \code{poly} shifted left by \code{k} coefficients, i.e.
   multiplied by $x^k$. 
 
void nmod_poly_shift_right(nmod_poly_t res, nmod_poly_t poly, long k)

   Set \code{res} to \code{poly} shifted right by \code{k} coefficients, i.e.
   divide by $x^k$ and throw away the remainder. If \code{k} is grearer than
   or equal to the length of poly, the result is the zero polynomial. 

*******************************************************************************

    Multiplication

*******************************************************************************

void _nmod_poly_mul_classical(mp_ptr res, mp_srcptr poly1, 
                    long len1, mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{(res, len1 + len2 - 1)} to the product of \code{(poly1, len1)}
    and \code{(poly2, len2)}. Assumes \code{len1 >= len2 > 0}.

void nmod_poly_mul_classical(nmod_poly_t res, 
                               const nmod_poly_t poly1, const nmod_poly_t poly2)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}.

void _nmod_poly_mullow_classical(mp_ptr res, mp_srcptr poly1, long len1, 
                           mp_srcptr poly2, long len2, long trunc, nmod_t mod)

    Sets \code{res} to the lower \code{trunc} coefficients of the product of 
    \code{(poly1, len1)} and \code{(poly2, len2)}.
    Assumes that \code{len1 >= len2 > 0} and \code{trunc > 0}.

void nmod_poly_mullow_classical(nmod_poly_t res, 
                  const nmod_poly_t poly1, const nmod_poly_t poly2, long trunc)

    Sets \code{res} to the lower \code{trunc} coefficients of the product 
    of \code{poly1} and \code{poly2}.

void _nmod_poly_mulhigh_classical(mp_ptr res, mp_srcptr poly1, 
            long len1, mp_srcptr poly2, long len2, long start, nmod_t mod)

    Computes the product of \code{(poly1, len1)} and \code{(poly2, len2)} 
    and writes the coefficients from \code{start} onwards into the high 
    coefficients of \code{res}, the remaining coefficients being arbitrary 
    but reduced.  Assumes that \code{len1 >= len2 > 0}.

void nmod_poly_mulhigh_classical(nmod_poly_t res, 
                  const nmod_poly_t poly1, const nmod_poly_t poly2, long start)

    Computes the product of \code{poly1} and \code{poly2} and writes the 
    coefficients from \code{start} onwards into the high coefficients of 
    \code{res}, the remaining coefficients being arbitrary but reduced.

void _nmod_poly_mul_KS(mp_ptr out, mp_srcptr in1, long len1, 
                     mp_srcptr in2, long len2, mp_bitcnt_t bits, nmod_t mod)

    Sets \code{res} to the product of \code{poly1} and \code{poly2} 
    assuming the output coefficients are at most the given number of 
    bits wide. If \code{bits} is set to $0$ an appropriate value is 
    computed automatically.  Assumes that \code{len1 >= len2 > 0}.

void nmod_poly_mul_KS(nmod_poly_t res, 
            const nmod_poly_t poly1, const nmod_poly_t poly2, mp_bitcnt_t bits)

    Sets \code{res} to the product of \code{poly1} and \code{poly2} 
    assuming the output coefficients are at most the given number of 
    bits wide. If \code{bits} is set to $0$ an appropriate value 
    is computed automatically.

void nmod_poly_mul(nmod_poly_t res, nmod_poly_t poly, nmod_poly_t poly2)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}.

void nmod_poly_mullow_n(nmod_poly_t res, nmod_poly_t poly1, 
                                         nmod_poly_t poly2, long trunc)

    Sets \code{res} to the first \code{trunc} coefficients of the 
    product of \code{poly1} and \code{poly2}.

void nmod_poly_mulhigh_n(nmod_poly_t res, nmod_poly_t poly1, 
                                          nmod_poly_t poly2, long n)

    Sets the high $n$ coefficients of \code{res} to the high $n$ 
    coefficients of the product of \code{poly1} and \code{poly2}, 
    the remaining coefficients being arbitrary.

*******************************************************************************

    Division

*******************************************************************************

void _nmod_poly_divrem_basecase(mp_ptr Q, mp_ptr R, 
           mp_srcptr A, long A_len, mp_srcptr B, long B_len, nmod_t mod)

    Finds $Q$ and $R$ such that $A = B Q + R$ with $\len(R) < \len(B)$.
    If $\len(B) = 0$ an exception is raised.

void nmod_poly_divrem_basecase(nmod_poly_t Q, 
                               nmod_poly_t R, nmod_poly_t A, nmod_poly_t B)

    Finds $Q$ and $R$ such that $A = B Q + R$ with $\len(R) < \len(B)$. 
    If $\len(B) = 0$ an exception is raised.

*******************************************************************************

    Derivative

*******************************************************************************

void nmod_poly_derivative(nmod_poly_t x_prime, nmod_poly_t x)

   Set \code{x_prime} to the derivative of \code{x}. 

*******************************************************************************

    Evaluation

*******************************************************************************

mp_limb_t nmod_poly_evaluate(nmod_poly_t poly, mp_limb_t c)

   Evaluate \code{poly} at the value \code{c} and reduce modulo the 
   modulus of \code{poly}. The value \code{c} should be reduced modulo
   the modulus. The algorithm used is Horner's method.

void nmod_poly_compose(nmod_poly_t res, nmod_poly_t poly1, nmod_poly_t poly2)

  Compose \code{poly1} with \code{poly2} and set \code{res} to the result,
  i.e. evaluate \code{poly1} at \code{poly2}. The algorithm used is 
  Horner's algorithm.
