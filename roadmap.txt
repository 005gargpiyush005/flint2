FLINT 2 Roadmap
===============

This documents sets out a list of functions which have been implemented in flint2 which are
not intended to be optimal implementations, and thus can be significantly improved in future
and also lists functions which have not been added, which would improve performance and
functionality were they added. 

Thus this document serves as a roadmap. Functions listed here are candidates for contributors
to consider working on to improve flint2.

fmpz_poly
---------

fmpz_poly_mul_SS (mul_SS) - missing
   Schoenhage-Strassen algorithm (SSA) for multiplying polynomials. Note SSA relies on a very 
   sophisticated FFT such as the one developed for MPIR, (but not used by MPIR yet), written by 
   Bill Hart.

fmpz_poly_mullow_SS_n (mullow_SS_n.c) - missing
   Computes the low n coefficients of an n x n multiplication. Relies on an FFT capable of 
   outputting only the low coefficients. Assumes the input polynomials (zero padded if
   necessary) are of the given length.

fmpz_poly_mulhigh_SS_n (mulhigh_SS_n.c) - missing
   Computes the high n coefficients of an n x n multiplication. Relies on an FFT capable of 
   outputting only the low coefficients. Assumes the input polynomials (zero padded if
   necessary) are of the given length.

fmpz_poly_mulmid_SS_n (mulmid_SS_n.c) - missing
   Use the FFT wraparound trick to obtain the middle product directly with the FFT.

fmpz_poly_mulmid_karatsuba (mulmid_karatsuba.c) - missing
   Implement a toom42 middle product for polynomials. This should be a transposition of the
   karatsuba algorithm as per Tellegen's principle.

fmpz_poly_mullow_KS_n (mullow_KS_n.c) - missing
   Computes the low n coefficients of an n x n multiplication. Relies on an FFT capable of 
   outputting only the low coefficients. Assumes the input polynomials (zero padded if
   necessary) are of the given length.

fmpz_poly_mulhigh_KS_n (mulhigh_KS_n.c) - missing
   Computes the high n coefficients of an n x n multiplication. Relies on an FFT capable of 
   outputting only the low coefficients. Assumes the input polynomials (zero padded if
   necessary) are of the given length.

fmpz_poly_mulmid_KS_n (mulmid_KS_n.c) - missing
   Use the FFT wraparound trick to obtain the middle product using Kronecker Segmentation.

fmpz_poly_mul_KS2 (mul_KS2.c) - missing
   Implement David Harvey's KS2 algorithm when coefficients have small coefficients.

fmpz_poly_mul_KS4 (mul_KS4.c) - missing
   Implement David Harvey's KS4 algorithm when coefficients have small coefficients.

fmpz_poly_mul (mul.c) 
   Currently only uses classical, karatsuba and KS multiplication. When Schoenhage-Strassen
   algorithm (SSA) is added, it should be used. Also need cutoffs to be tuned per architecture.
   
fmpz_poly_mullow_n (mullow_n.c) 
   Computes the low n coefficients of an n x n multiplication. Use tuned cutoffs to select
   the other implemented algorithms for this. Also use other algorithms for this when they
   become available.

fmpz_poly_mulhigh_n (mulhigh_n.c)
   Computes the high n coefficients of an n x n multiplication. Use tuned cutoffs to select
   the other implemented algorithms for this. Also use other algorithms for this when they
   become available.

fmpz_poly_sqr_classical_n (sqr_classical_n.c) - missing
   Square a polynomial using a special version of the classical multiplication algorithm.

fmpz_poly_sqrlow_classical_n (sqr_classical_n.c) - missing
   Square a polynomial using a special version of the classical multiplication algorithm
   which truncates to length n.

fmpz_poly_sqr_karatsuba_n (sqr_karatsuba_n.c) - missing
   Square a polynomial using a special version of the karatsuba multiplication algorithm.
   Some version of the odd/even karatsuba algorithm might work here.

fmpz_poly_sqr_karatsuba_n (sqr_karatsuba_n.c) - missing
   Square a polynomial using a special version of the karatsuba multiplication algorithm
   which truncates to length n.

fmpz_poly_sqr_n (sqr_n.c) - missing
   Square a poly using tuned crossovers for various algorithms. KS already deals optimally
   with squaring, but there should be classical and karatsuba square algorithms.

fmpz_poly_sqrlow_n (sqr_n.c) - missing
   Square a poly using tuned crossovers for various algorithms that truncate to length n. 
   mullow_KS will already deal optimally with truncated squaring, but there should be classical 
   and karatsuba square algorithms which truncate. sqrhigh is probably not useful so need not 
   be implemented.

nmod_poly
---------

nmod_poly_mul_classical (mul_classical.c)
   Currently two cases are distinguished: a) where the entire multiplication can be done with
   everything accumulating in a single limb and a single final reduction, b) where reduction
   is performed every operation. In case (b) the addmul code distinguishes the cases where 
   the addmul will fit in a single limb and where it will not. At the very least mul_classical
   should accumulate into 2 or 3 limbs where necessary and do a final reduction at the end.
   Probably it makes sense to accumulate into 2 limbs and always keep the top limb reduced mod
   n, which is less expensive. Also, when everything fits into a single limb, mpn_mul can be
   used directly to multiply the polys before reduction.

nmod_poly_mullow_classical (mullow_classical.c)    
   Can be optimised in the same way as mul_classical.

nmod_poly_mulhigh_classical (mullow_classical.c) 
   Can be optimised in the same way as mul_classical.

nmod_poly_mulmid_classical (mulmid_classical.c) - missing
   Should have a similar prototype to fmpz_poly_mulhigh_classical, but for nmod_polys.

nmod_poly_sqrlow_classical_n (mullow_classical.c) - missing
   Should have a similar prototype to fmpz_poly_sqrlow_classical_n, but for nmod_polys.

nmod_poly_sqr_classical_n (mullow_classical.c) - missing
   Should have a similar prototype to fmpz_poly_sqr_classical_n, but for nmod_polys.

nmod_poly_mullow_KS_n (mullow_KS_n.c) - missing
   When the FFT has a truncated multiplication it is good to use this to get a mullow_KS.

nmod_poly_mulmid_KS_n (mulmid_KS_n.c) - missing
   The FFT wraparound trick can be used to get a mulmid.

nmod_poly_mul_KS2 (mul_KS2.c) - missing
   David Harvey's KS2 trick.

nmod_poly_mullow_KS2_n (mullow_KS2_n.c) - missing
   David Harvey's KS2 trick, truncating.

nmod_poly_mul_KS4 (mul_KS4.c) - missing
   David Harvey's KS4 trick.

nmod_poly_mullow_KS4_n (mullow_KS4_n.c) - missing
   David Harvey's KS4 trick, truncating.

nmod_poly_mul_SN.c (mul_SN.c) - missing
   Implement the Schoenhage-Nussbaumer FFT

nmod_poly_mullow_SN_n.c (mullow_SN_n.c) - missing
   Use the Schoenhage-Nussbaumer FFT.

nmod_poly_mulhigh_SN_n.c (mulhigh_SN_n.c) - missing
   Use the Schoenhage-Nussbaumer FFT.

nmod_poly_mulmid_SN.c (mulmid_SN.c) - missing
   Use a variant of the Schoenhage-Nussbaumer FFT for middle product.

nmod_poly_mul (mul.c)
   Use the other available routines with tuned cutoffs, where available.

nmod_poly_mulhigh_n (mulhigh_n.c)
   Use the other available routines with tuned cutoffs, where available.

nmod_poly_mullow_n (mullow_n.c)
   Use the other available routines with tuned cutoffs, where available.

nmod_poly_mullow_precache_n (mullow_precache_n.c) - missing
   Precache the FFT when using the KS algorithm.

nmod_poly_mulmid_n (mul.c) - missing
   Use the other available routines with tuned cutoffs, where available.

nmod_poly_mulmid_precache_n (mulmid_precache_n.c) - missing
   Precache the FFT when using the KS middle product algorithm.


