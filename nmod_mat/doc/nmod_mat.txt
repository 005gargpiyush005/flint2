/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 Fredrik Johansson

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void nmod_mat_init(nmod_mat_t mat, long rows, long cols, mp_limb_t n)

    Initialises mat to a (rows x cols) matrix with coefficients
    mod n, where n > 1. All elements are set to zero.

void nmod_mat_clear(nmod_mat_t mat)

   Clears the matrix and releases any memory it used. The matrix 
   cannot be used again until it is initialised.


*******************************************************************************

    Printing

*******************************************************************************

void nmod_mat_print_pretty(nmod_mat_t mat)

    Pretty-prints mat to stdout.


*******************************************************************************

    Random matrix generation

*******************************************************************************

void nmod_mat_randtest(nmod_mat_t mat)

    Sets the elements to random numbers between 0 and m-1 inclusive where m
    is the modulus of mat.

void nmod_mat_randfull(nmod_mat_t mat)

    Sets the element to random numbers close to the modulus of the matrix.


*******************************************************************************

    Matrix arithmetic

*******************************************************************************


void nmod_mat_transpose(nmod_mat_t B, nmod_mat_t A)

    Sets B to the transpose of A. Dimensions must be compatible.
    B and A may be the same object if the matrix is square.

void nmod_mat_add(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)

    Computes C = A + B. Dimensions must be identical.

void nmod_mat_mul(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)

    Computes the matrix product C = A * B. Dimensions must be compatible
    for matrix multiplication. C is not allowed to be aliased with A or B.

_nmod_mat_mul_1(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)
_nmod_mat_mul_2(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)
_nmod_mat_mul_3(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)
_nmod_mat_mul_transpose_1(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)
_nmod_mat_mul_transpose_2(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)
_nmod_mat_mul_transpose_3(nmod_mat_t C, nmod_mat_t A, nmod_mat_t B)

    Computes C = A * B or C = A * B^T respectively, using classical
    matrix multiplication. That is, for each i and j, C[i][j] is set to
    the dot product of row i of A with column j of B (row j of B
    when transposed).

    The "_X" version uses a register X limbs wide to accumulate the dot
    product, and a modular reduction is performed only at the end.
    The caller must ensure that elements are sufficiently small for
    overflow not to occur.

    Let k be the dot product size (i.e. the number of columns of A)
    and let a and b the largest absolute values of the elements in A and B
    respectively. Then the following conditions are sufficient to guarantee
    correctness:

        1  :   k*a*b         < 2^FLINT_BITS
        2  :   k*a*b         < 2^(2*FLINT_BITS)
        3  :   always

    Dimensions must be compatible for matrix multiplication. C is not
    allowed to be aliased with A or B.
